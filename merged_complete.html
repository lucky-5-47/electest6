<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>电路设计平台</title>
    <link rel="stylesheet" href="extracted-styles.css">
    <!-- 引入磁吸功能 -->
    <script src="magnetic-snap.js"></script>
    <!-- 引入手势控制功能 -->
    <script src="gesture-control.js"></script>
    <!-- 引入保存功能 -->
    <script src="save.js"></script>
    <!-- 引入打开功能 -->
    <script src="open.js"></script>
    <!-- 引入导出图片功能 -->
    <script src="export-image.js"></script>
    <!-- 引入撤销功能 -->
    <script src="undo.js"></script>

    <!-- 引入按钮元件 -->
    <link rel="stylesheet" href="push-button.css">
    <script src="push-button.js"></script>
    <!-- 引入开关元件 -->
    <link rel="stylesheet" href="switch.css">
    <script src="switch.js"></script>
    <!-- 引入线路组件功能 -->
    <script src="circuit-components.js"></script>
    <!-- 引入LED二极管组件 -->
    <script src="led-diode.js"></script>
    <!-- 引入引脚配置测试脚本
    <script src="test-pin-config.js"></script> -->
    <!-- 引入调试脚本
    <script src="debug-button-click.js"></script> -->
    <!-- 引入新建 -->
    <script src="new-file-function.js"></script>
    <!-- 引入退出-->
    <script src="exit-function.js"></script>
    <!-- 引入74LS138组件 -->
    <script src="74ls138.js"></script>
    <!-- 引入74LS151组件 -->
    <script src="74ls151.js"></script>
    <!-- 引入74LS161组件 -->
    <script src="74ls161.js"></script>
    <!-- 引入74LS175组件 -->
    <script src="74ls175.js"></script>
    <!-- 引入74LS160组件 -->
    <script src="74ls160.js"></script>
    <!-- 引入74LS280组件 -->
    <script src="74280.js"></script>
    <!-- 引入74139组件 -->
    <script src="74139.js"></script>
    <!-- 引入模N计数器组件 -->
    <script src="mod_n_counter.js"></script>
    <!-- 引入二进制异步计数器组件 -->
    <script src="binary-async-counter.js"></script>
    <!-- 引入多数表决器组件 -->
    <script src="majority-voter.js"></script>
    <!-- 引入74LS153组件 -->
    <script src="74ls153_final.js"></script>

    <!-- 预初始化全局对象，确保外部脚本可以访问 -->
    <script>
        // 提前创建全局对象，避免外部脚本加载时找不到
        window.componentSvgs = window.componentSvgs || {};
        window.logicFunctions = window.logicFunctions || {};

        console.log('全局对象预初始化完成');
    </script>

    <!-- 修复下拉菜单层级问题 -->
    <style>
        /* 只修复层级问题，保持原有样式和hover效果 */
        .nav {
            z-index: 1000 !important;
        }

        .btli:hover .droplist {
            display: block !important;
            z-index: 1003 !important;
        }

        .droplist {
            z-index: 1002 !important;
        }
    </style>
</head>
</head>

<body>
    <!-- 引入时序逻辑组件脚本 - 放在body开头确保在内联脚本前加载 -->
    <script src="counter.js"></script>
    <script src="jk-flipflop.js"></script>
    <script src="rs-latch.js"></script>
    <script src="t-flipflop.js"></script>
    <script src="tp-flipflop.js"></script>

    <!-- 全局输入端口配置函数 -->
    <script>
        // 应用输入端口配置
        function applyInputPortConfig(button) {
            console.log('开始执行 applyInputPortConfig');
            
            try {
                const dialog = button.closest('.config-dialog');
                if (!dialog) {
                    console.error('找不到配置对话框');
                    return;
                }
                
                const componentId = dialog.dataset.componentId;
                const component = document.querySelector(`[data-id="${componentId}"]`);
                console.log('组件ID:', componentId, '组件:', component);
                
                // 获取位宽设置
                const bitWidthSelect = dialog.querySelector('#input-bitwidth-select');
                const customInput = dialog.querySelector('#custom-bitwidth');
                
                let newBitWidth;
                if (bitWidthSelect.value === 'custom') {
                    newBitWidth = parseInt(customInput.value) || 1;
                } else {
                    newBitWidth = parseInt(bitWidthSelect.value);
                }
                
                console.log('新位宽:', newBitWidth);
                
                if (newBitWidth < 1 || newBitWidth > 64) {
                    alert('位宽必须在 1-64 之间！');
                    return;
                }
                
                // 获取二进制输入
                const inputValue = dialog.querySelector('#dataInput').value;
                console.log('输入的二进制值:', inputValue);
                
                if (inputValue.trim()) {
                    try {
                        // 检查二进制格式
                        if (!/^[01]+$/.test(inputValue)) {
                            throw new Error('二进制数只能包含0和1');
                        }
                        if (inputValue.length > newBitWidth) {
                            throw new Error(`二进制数的位数不能超过${newBitWidth}`);
                        }
                        
                        // 转换为二进制数组，补齐到指定位宽
                        const paddedBinary = inputValue.padStart(newBitWidth, '0');
                        const newData = paddedBinary.split('').map(bit => parseInt(bit));
                        console.log('转换后的数据数组:', newData);
                        
                        // 更新数据 - 使用全局函数
                        if (typeof window.setComponentBitWidth === 'function') {
                            window.setComponentBitWidth(componentId, newBitWidth);
                            window.setComponentMultiBitData(componentId, newData);
                            console.log('使用全局函数更新数据成功');
                        } else {
                            console.error('全局函数未找到，等待DOM加载完成...');
                            // 延迟执行，等待函数加载
                            setTimeout(() => {
                                if (typeof window.setComponentBitWidth === 'function') {
                                    window.setComponentBitWidth(componentId, newBitWidth);
                                    window.setComponentMultiBitData(componentId, newData);
                                    window.updatePortDisplay(componentId);
                                    if (component && typeof window.propagateSignal === 'function') {
                                        window.propagateSignal(component);
                                    }
                                    console.log('延迟执行成功');
                                } else {
                                    console.error('延迟执行仍然无法找到函数');
                                }
                            }, 100);
                        }
                        
                    } catch (error) {
                        console.error('数据处理错误:', error);
                        alert('错误: ' + error.message);
                        return;
                    }
                } else {
                    // 只更新位宽，不更新数值
                    console.log('只更新位宽，不更新数值');
                    if (typeof window.setComponentBitWidth === 'function') {
                        window.setComponentBitWidth(componentId, newBitWidth);
                    } else {
                        setTimeout(() => {
                            if (typeof window.setComponentBitWidth === 'function') {
                                window.setComponentBitWidth(componentId, newBitWidth);
                                window.updatePortDisplay(componentId);
                                if (component && typeof window.propagateSignal === 'function') {
                                    window.propagateSignal(component);
                                }
                            }
                        }, 100);
                    }
                }
                
                // 更新显示
                if (typeof window.updatePortDisplay === 'function') {
                    console.log('调用 updatePortDisplay');
                    window.updatePortDisplay(componentId);
                    
                    // 传播信号
                    if (component && typeof window.propagateSignal === 'function') {
                        console.log('调用 propagateSignal');
                        window.propagateSignal(component);
                    }
                } else {
                    console.error('updatePortDisplay 函数未找到');
                }
                
                // 检查最终状态
                setTimeout(() => {
                    if (typeof window.getComponentMultiBitData === 'function') {
                        const finalData = window.getComponentMultiBitData(componentId);
                        console.log('最终数据状态:', finalData);
                        
                        // 检查SVG显示元素
                        const textElement = component ? component.querySelector('#input-text') : null;
                        console.log('SVG文本元素:', textElement);
                        if (textElement) {
                            console.log('当前显示内容:', textElement.textContent);
                        }
                    }
                }, 200);
                
                // 关闭对话框
                document.body.removeChild(dialog);
                console.log('applyInputPortConfig 执行成功');
                
            } catch (error) {
                console.error('applyInputPortConfig 执行失败:', error);
                alert('配置失败: ' + error.message);
            }
        }
        
        // 取消输入端口配置
        function cancelInputPortConfig(button) {
            const dialog = button.closest('.config-dialog');
            document.body.removeChild(dialog);
        }
        
        // 应用输出端口配置
        function applyOutputPortConfig(button) {
            try {
                const dialog = button.closest('.config-dialog');
                const componentId = dialog.dataset.componentId;
                const component = document.querySelector(`[data-id="${componentId}"]`);
                
                // 获取位宽设置
                const bitWidthSelect = dialog.querySelector('#output-bitwidth-select');
                const customInput = dialog.querySelector('#output-custom-bitwidth');
                
                let newBitWidth;
                if (bitWidthSelect.value === 'custom') {
                    newBitWidth = parseInt(customInput.value) || 1;
                } else {
                    newBitWidth = parseInt(bitWidthSelect.value);
                }
                
                if (newBitWidth < 1 || newBitWidth > 64) {
                    alert('位宽必须在 1-64 之间！');
                    return;
                }
                
                // 更新位宽
                if (typeof window.setComponentBitWidth === 'function') {
                    window.setComponentBitWidth(componentId, newBitWidth);
                    window.updatePortDisplay(componentId);
                } else {
                    setTimeout(() => {
                        if (typeof window.setComponentBitWidth === 'function') {
                            window.setComponentBitWidth(componentId, newBitWidth);
                            window.updatePortDisplay(componentId);
                        }
                    }, 100);
                }
                
                document.body.removeChild(dialog);
            } catch (error) {
                console.error('输出端口配置错误:', error);
                alert('配置失败: ' + error.message);
            }
        }
        
        // 取消输出端口配置
        function cancelOutputPortConfig(button) {
            const dialog = button.closest('.config-dialog');
            document.body.removeChild(dialog);
        }
    </script>
    <div class="nav">
        <ul class="navlist">
            <li class="btli"><a href="#">文件(F)</a>
                <ul class="droplist">
                    <li><a href="#">打开</a></li>
                    <li><a href="#">保存</a></li>
                    <li><a href="#">另存为</a></li>
                    <li><a href="#">导出图片</a></li>
                    <li><a href="#">新建</a></li>
                    <li><a href="#">退出</a></li>
                </ul>
            </li>
            <li class="btli"><a href="#">编辑(E)</a>
                <ul class="droplist">
                    <li><a href="#">撤销</a></li>
                    <li><a href="#">剪切</a></li>
                    <li><a href="#">复制</a></li>
                    <li><a href="#">粘贴</a></li>
                    <li><a href="#">删除</a></li>
                </ul>
            </li>
            <li class="btli"><a href="#">视图(V)</a>
                <ul class="droplist">
                    <li><a href="#">全屏</a></li>
                    <li><a href="#">放大</a></li>
                    <li><a href="#">缩小</a></li>
                    <li><a href="#">边界</a></li>
                    <li><a href="#">工具栏</a></li>
                </ul>
            </li>
            <li class="btli"><a href="#">绘制(P)</a>
                <ul class="droplist">
                    <li><a href="#">元器件</a></li>
                    <li><a href="#">导线</a></li>
                    <li><a href="#">总线</a></li>
                    <li><a href="#">结</a></li>
                    <li><a href="#">连接器</a></li>
                </ul>
            </li>
            <li class="btli"><a href="#">工具(T)</a>
                <ul class="droplist">
                    <li><a href="#">元器件向导</a></li>
                    <li><a href="#">电路向导</a></li>
                    <li><a href="#">数据库</a></li>
                    <li><a href="#">清除</a></li>
                    <li><a href="#">切换</a></li>
                </ul>
            </li>
        </ul>
    </div>

    <!-- 快捷工具栏 -->
    <div class="toolbar-container">
        <div class="quick-toolbar">
            <!-- 文字工具 -->
            <div class="toolbar-item" data-tool="text" title="文字工具">
                <svg viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
                    <path d="M5,4V7H10.5V19H13.5V7H19V4H5Z"/>
                </svg>
                <div class="tooltip">文字工具</div>
            </div>

            <div class="toolbar-separator"></div>

            <!-- 输入端口 -->
            <div class="toolbar-item" data-tool="input" title="输入端口">
                <svg viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
                    <rect x="4" y="8" width="12" height="8" rx="2" fill="#006400" stroke="black" stroke-width="1"/>
                    <text x="10" y="13" font-family="Arial" font-size="6" fill="white" text-anchor="middle">I</text>
                    <circle cx="18" cy="12" r="2" fill="black"/>
                </svg>
                <div class="tooltip">输入端口</div>
            </div>

            <!-- 输出端口 -->
            <div class="toolbar-item" data-tool="output" title="输出端口">
                <svg viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
                    <circle cx="6" cy="12" r="2" fill="black"/>
                    <rect x="8" y="8" width="12" height="8" rx="2" fill="#008000" stroke="black" stroke-width="1"/>
                    <text x="14" y="13" font-family="Arial" font-size="6" fill="white" text-anchor="middle">O</text>
                </svg>
                <div class="tooltip">输出端口</div>
            </div>

            <div class="toolbar-separator"></div>

            <!-- 与门 -->
            <div class="toolbar-item" data-tool="and-gate" title="与门">
                <svg viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="1.5" width="24" height="24">
                    <path d="M4 8 L12 8 A6 6 0 0 1 12 16 L4 16 Z"/>
                    <circle cx="2" cy="10" r="1" fill="black"/>
                    <circle cx="2" cy="14" r="1" fill="black"/>
                    <circle cx="20" cy="12" r="1" fill="black"/>
                </svg>
                <div class="tooltip">与门</div>
            </div>

            <!-- 或门 -->
            <div class="toolbar-item" data-tool="or-gate" title="或门">
                <svg viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="1.5" width="24" height="24">
                    <path d="M4 8 Q12 8 18 12 Q12 16 4 16 Q8 12 4 8"/>
                    <circle cx="2" cy="10" r="1" fill="black"/>
                    <circle cx="2" cy="14" r="1" fill="black"/>
                    <circle cx="20" cy="12" r="1" fill="black"/>
                </svg>
                <div class="tooltip">或门</div>
            </div>

            <!-- 非门 -->
            <div class="toolbar-item" data-tool="not-gate" title="非门">
                <svg viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="1.5" width="24" height="24">
                    <path d="M4 8 L16 12 L4 16 Z"/>
                    <circle cx="17" cy="12" r="1.5" fill="none"/>
                    <circle cx="2" cy="12" r="1" fill="black"/>
                    <circle cx="20" cy="12" r="1" fill="black"/>
                </svg>
                <div class="tooltip">非门</div>
            </div>


        </div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <h3>电路元件库</h3>

            <div class="component-list">
                <details>
                    <summary>逻辑门</summary>
                    <ul>
                        <li data-type="and-gate">与门</li>
                        <li data-type="or-gate">或门</li>
                        <li data-type="not-gate">非门</li>
                        <li data-type="xor-gate">异或门</li>
                        <li data-type="nand-gate">与非门</li>
                    </ul>
                </details>
            </div>

            <div class="component-list">
                <details>
                    <summary>时序逻辑</summary>
                    <ul>
                        <li data-type="d-flipflop">D触发器</li>
                        <li data-type="jk-flipflop">JK触发器</li>
                        <li data-type="t-flipflop">T触发器</li>
                        <li data-type="tp-flipflop">T'触发器</li>
                        <li data-type="counter">计数器</li>
                        <li data-type="rs-latch">RS锁存器</li>
                    </ul>
                </details>
            </div>

            <div class="component-list">
                <details>
                    <summary>输入输出</summary>
                    <ul>
                        <li data-type="input">输入端口</li>
                        <li data-type="output">输出端口</li>
                        <li data-type="clock">时钟信号</li>
                        <li data-type="push-button">按钮</li>
                        <li data-type="switch">开关</li>
                        <li data-type="led-diode">LED二极管</li>
                    </ul>
                </details>
            </div>

            <div class="component-list">
                <details>
                    <summary>运算器</summary>
                    <ul>
                        <li data-type="adder">加法器</li>
                        <li data-type="subtractor">减法器</li>
                        <li data-type="divider">除法器</li>
                        <li data-type="complement">求补器</li>
                    </ul>
                </details>
            </div>

            <div class="component-list">
                <details>
                    <summary>线路</summary>
                    <ul>
                        <li data-type="pin">引脚</li>
                        <li data-type="splitter">分线器</li>
                        <li data-type="probe">探针</li>
                        <li data-type="power">电源</li>
                        <li data-type="ground">接地</li>
                    </ul>
                </details>
            </div>

            <div class="component-list">
                <details>
                    <summary>常见实验</summary>
                    <ul>
                        <li data-type="74ls175">74LS175 四位寄存器</li>
                        <li>
                            <details>
                                <summary>同步计数器</summary>
                                <ul style="margin-left: 20px;">
                                    <li data-type="74ls160">74LS160</li>
                                    <li data-type="74ls161">74LS161</li>
                                </ul>
                            </details>
                        </li>
                        <li data-type="mod-n-counter">模N计数器</li>
                        <li>
                            <details>
                                <summary>多数表决器</summary>
                                <ul style="margin-left: 20px;">
                                    <li data-type="majority-voter-3">3输入表决器</li>
                                    <li data-type="majority-voter-5">5输入表决器</li>
                                    <li data-type="majority-voter-7">7输入表决器</li>
                                </ul>
                            </details>
                        </li>
                        <li data-type="binary-async-counter">异步二进制计数器</li>
                        <li>
                            <details>
                                <summary>数据选择器</summary>
                                <ul style="margin-left: 20px;">
                                    <li data-type="74ls151">74LS151 8选1</li>
                                    <li data-type="74ls153">74LS153 4选1</li>
                                </ul>
                            </details>
                        </li>
                        <li data-type="74280">74LS280 奇偶校验器</li>
                        <li>
                            <details>
                                <summary>数据分配器</summary>
                                <ul style="margin-left: 20px;">
                                    <li data-type="74ls138">74LS138 1路-8路</li>
                                    <li data-type="74139">74LS139 1路-4路</li>
                                </ul>
                            </details>
                        </li>
                        <li data-type="complement">待定</li>
                    </ul>
                </details>
            </div>
        </div>

        <div class="canvas-container">
            <div class="canvas" id="circuit-canvas">
                <svg id="wire-layer" xmlns="http://www.w3.org/2000/svg"></svg>
            </div>
        </div>

        <!-- 右键菜单 -->
        <div id="context-menu" class="context-menu">
            <div class="context-menu-item" id="delete-item">
                <span class="danger">删除</span>
            </div>
        </div>


    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const canvas = document.getElementById('circuit-canvas');
            const wireLayer = document.getElementById('wire-layer');
            const componentItems = document.querySelectorAll('.component-list li');
            const contextMenu = document.getElementById('context-menu');
            const deleteItem = document.getElementById('delete-item');
            const toolbarItems = document.querySelectorAll('.toolbar-item');
            let startAnchor = null;
            let currentTool = null;

            // 调试函数：检查74139组件加载状态
            window.debug74139Status = function() {
                console.log('=== 74139组件加载状态检查 ===');
                console.log('window.ls139Component:', window.ls139Component);
                console.log('window.ls139Logic:', window.ls139Logic);
                console.log('componentSvgs["74139"]:', componentSvgs ? componentSvgs['74139'] : 'componentSvgs未定义');
                console.log('window.componentSvgs["74139"]:', window.componentSvgs ? window.componentSvgs['74139'] : 'window.componentSvgs未定义');
                console.log('logicFunctions["74139"]:', typeof logicFunctions !== 'undefined' ? logicFunctions['74139'] : 'logicFunctions未定义');
                console.log('window.logicFunctions["74139"]:', window.logicFunctions ? window.logicFunctions['74139'] : 'window.logicFunctions未定义');
                console.log('window.initialize74139Component:', typeof window.initialize74139Component);
                console.log('===============================');
            };

            // 5秒后自动检查一次加载状态
            setTimeout(() => {
                console.log('自动检查74139组件加载状态:');
                window.debug74139Status();
            }, 5000);

            // 初始化磁吸功能
            const magneticSnap = new MagneticSnap({
                gridSize: 20,           // 与CSS网格大小一致
                snapDistance: 15,       // 网格磁吸距离
                anchorSnapDistance: 50, // 锚点磁吸距离（增加到50像素，更容易连接）
                enabled: true           // 默认启用
            });

            // 初始化手势控制功能
            const gestureControl = new GestureControl();

            // 监听手势模式变化
            document.addEventListener('gestureMode', function(e) {
                const { mode, isGrabMode, isConnectMode } = e.detail;
                console.log('手势模式变化:', mode);

                // 显示模式提示
                gestureControl.showModeHint();

                // 根据模式调整交互行为
                if (isConnectMode) {
                    // 连线模式：禁用组件拖拽，启用连线功能
                    canvas.classList.add('connect-mode');
                } else {
                    // 抓取模式：启用组件拖拽，正常操作
                    canvas.classList.remove('connect-mode');
                }
            });
            // 存储所有连线与锚点的关联关系
            const wires = [];
            // 确保全局访问
            window.wires = wires;

            // 创建带转弯的连线
            function createBentWire(startX, startY, endX, endY) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('class', 'wire');
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', 'black');
                path.setAttribute('stroke-width', '2');
                path.setAttribute('stroke-dasharray', 'none'); // 确保是实线

                // 计算转弯路径
                const pathData = calculateBentPath(startX, startY, endX, endY);
                path.setAttribute('d', pathData);

                return path;
            }

            // 计算转弯路径
            function calculateBentPath(startX, startY, endX, endY) {
                const dx = endX - startX;
                const dy = endY - startY;

                // 如果距离很近，使用直线
                if (Math.abs(dx) < 50 && Math.abs(dy) < 50) {
                    return `M ${startX} ${startY} L ${endX} ${endY}`;
                }

                // 计算中间转弯点
                let midX, midY;

                // 根据相对位置决定转弯方式
                if (Math.abs(dx) > Math.abs(dy)) {
                    // 水平距离更大，先水平后垂直
                    midX = startX + dx * 0.7;
                    midY = startY;
                } else {
                    // 垂直距离更大，先垂直后水平
                    midX = startX;
                    midY = startY + dy * 0.7;
                }

                // 创建带圆角的路径
                const cornerRadius = 10;

                if (Math.abs(dx) > Math.abs(dy)) {
                    // 水平优先路径
                    if (dx > 0) {
                        // 向右
                        if (dy > 0) {
                            // 向下
                            return `M ${startX} ${startY} L ${midX - cornerRadius} ${startY} Q ${midX} ${startY} ${midX} ${startY + cornerRadius} L ${midX} ${endY - cornerRadius} Q ${midX} ${endY} ${midX + cornerRadius} ${endY} L ${endX} ${endY}`;
                        } else {
                            // 向上
                            return `M ${startX} ${startY} L ${midX - cornerRadius} ${startY} Q ${midX} ${startY} ${midX} ${startY - cornerRadius} L ${midX} ${endY + cornerRadius} Q ${midX} ${endY} ${midX + cornerRadius} ${endY} L ${endX} ${endY}`;
                        }
                    } else {
                        // 向左
                        if (dy > 0) {
                            // 向下
                            return `M ${startX} ${startY} L ${midX + cornerRadius} ${startY} Q ${midX} ${startY} ${midX} ${startY + cornerRadius} L ${midX} ${endY - cornerRadius} Q ${midX} ${endY} ${midX - cornerRadius} ${endY} L ${endX} ${endY}`;
                        } else {
                            // 向上
                            return `M ${startX} ${startY} L ${midX + cornerRadius} ${startY} Q ${midX} ${startY} ${midX} ${startY - cornerRadius} L ${midX} ${endY + cornerRadius} Q ${midX} ${endY} ${midX - cornerRadius} ${endY} L ${endX} ${endY}`;
                        }
                    }
                } else {
                    // 垂直优先路径
                    if (dy > 0) {
                        // 向下
                        if (dx > 0) {
                            // 向右
                            return `M ${startX} ${startY} L ${startX} ${midY - cornerRadius} Q ${startX} ${midY} ${startX + cornerRadius} ${midY} L ${endX - cornerRadius} ${midY} Q ${endX} ${midY} ${endX} ${midY + cornerRadius} L ${endX} ${endY}`;
                        } else {
                            // 向左
                            return `M ${startX} ${startY} L ${startX} ${midY - cornerRadius} Q ${startX} ${midY} ${startX - cornerRadius} ${midY} L ${endX + cornerRadius} ${midY} Q ${endX} ${midY} ${endX} ${midY + cornerRadius} L ${endX} ${endY}`;
                        }
                    } else {
                        // 向上
                        if (dx > 0) {
                            // 向右
                            return `M ${startX} ${startY} L ${startX} ${midY + cornerRadius} Q ${startX} ${midY} ${startX + cornerRadius} ${midY} L ${endX - cornerRadius} ${midY} Q ${endX} ${midY} ${endX} ${midY - cornerRadius} L ${endX} ${endY}`;
                        } else {
                            // 向左
                            return `M ${startX} ${startY} L ${startX} ${midY + cornerRadius} Q ${startX} ${midY} ${startX - cornerRadius} ${midY} L ${endX + cornerRadius} ${midY} Q ${endX} ${midY} ${endX} ${midY - cornerRadius} L ${endX} ${endY}`;
                        }
                    }
                }
            }

            // 更新连线路径（用于元件移动时）
            function updateWirePath(wireElement, startX, startY, endX, endY) {
                if (wireElement.tagName === 'path') {
                    // 对于path元素，重新计算路径
                    const pathData = calculateBentPath(startX, startY, endX, endY);
                    wireElement.setAttribute('d', pathData);
                } else {
                    // 对于line元素（向后兼容）
                    wireElement.setAttribute('x1', startX);
                    wireElement.setAttribute('y1', startY);
                    wireElement.setAttribute('x2', endX);
                    wireElement.setAttribute('y2', endY);
                }
            }


            // 存储所有元件的状态
            const componentStates = new Map();
            // 将componentStates设为全局变量，以便配置对话框可以访问
            window.componentStates = componentStates;
            // 存储输入/输出端口的位宽配置
            const componentBitWidth = new Map();
            // 存储多位数据端口的具体数值
            const componentMultiBitData = new Map();
            // 存储锚点连接关系 - 每个锚点可以连接多个其他锚点
            const anchorConnections = new Map();
            // 确保全局访问
            window.anchorConnections = anchorConnections;
            // 当前选中的元素
            let selectedElement = null;
            // 鼠标下的组件
            let hoveredComponent = null;











            // 时序逻辑支持
            const sequentialElements = new Map(); // 存储时序元件的状态和历史
            const clockEdgeDetection = new Map(); // 时钟边沿检测
            const updateQueue = []; // 时序更新队列

            // 确保全局访问
            window.sequentialElements = sequentialElements;
            window.clockEdgeDetection = clockEdgeDetection;

            // 元件SVG模板
            const componentSvgs = {
                'or-gate': `
                    <svg class="component-svg" viewBox="0 0 200 100" xmlns="http://www.w3.org/2000/svg">
                        <path d="M50,30 Q120,30 150,60 Q120,90 50,90" fill="none" stroke="black" stroke-width="2"/>
                        <line x1="50" y1="30" x2="50" y2="90" stroke="black" stroke-width="2"/>
                        <text x="85" y="65" font-family="Arial" font-size="16">OR</text>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="45" r="5" fill="black"/>
                        <line x1="25" y1="45" x2="50" y2="45" stroke="black" stroke-width="2"/>
                        <text x="5" y="50" font-family="Arial" font-size="12">A</text>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="75" r="5" fill="black"/>
                        <line x1="25" y1="75" x2="50" y2="75" stroke="black" stroke-width="2"/>
                        <text x="5" y="80" font-family="Arial" font-size="12">B</text>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="60" r="5" fill="black"/>
                        <line x1="150" y1="60" x2="175" y2="60" stroke="black" stroke-width="2"/>
                        <text x="185" y="65" font-family="Arial" font-size="12">Y</text>
                    </svg>
                `,
                'input': `
                    <svg class="component-svg" viewBox="0 0 120 60" xmlns="http://www.w3.org/2000/svg">
                        <g id="input-group" transform="translate(60, 30)">
                            <rect id="input-bg" x="-50" y="-20" width="50" height="40" rx="5" fill="#006400" stroke="black" stroke-width="2" class="state-0"/>
                            <!-- 数据值显示 -->
                            <text id="input-text" class="state-text" x="-25" y="-2" font-family="Arial" font-size="14" font-weight="bold" text-anchor="middle" fill="white">0</text>
                            <!-- 位宽标签显示 -->
                            <text id="input-width-label" x="-25" y="12" font-family="Arial" font-size="8" text-anchor="middle" fill="white">1bit</text>
                            <!-- 输出锚点 -->
                            <circle class="anchor output-anchor" data-anchor-type="output" cx="0" cy="0" r="5" fill="black"/>
                            <line x1="-5" y1="0" x2="0" y2="0" stroke="black" stroke-width="2"/>
                            <!-- 多位指示器(当位宽>1时显示) -->
                            <g id="multi-bit-indicator" style="display: none;">
                                <rect x="-45" y="15" width="40" height="8" fill="#004400" stroke="black" stroke-width="1" rx="2"/>
                                <text x="-25" y="20" font-family="Arial" font-size="6" text-anchor="middle" fill="white">MULTI</text>
                            </g>
                        </g>
                    </svg>
                `,
                'output': `
                    <svg class="component-svg" viewBox="-10 0 130 60" xmlns="http://www.w3.org/2000/svg">
                        <g id="output-group" transform="translate(60, 30)">
                            <rect id="output-bg" x="-50" y="-20" width="50" height="40" rx="5" fill="#008000" stroke="black" stroke-width="2" class="state-0"/>
                            <!-- 数据值显示 -->
                            <text id="output-text" class="state-text" x="-25" y="-2" font-family="Arial" font-size="14" font-weight="bold" text-anchor="middle" fill="white">0</text>
                            <!-- 位宽标签显示 -->
                            <text id="output-width-label" x="-25" y="12" font-family="Arial" font-size="8" text-anchor="middle" fill="white">1bit</text>
                            <!-- 输入锚点 -->
                            <circle class="anchor input-anchor" data-anchor-type="input" cx="-60" cy="0" r="5" fill="black"/>
                            <line x1="-55" y1="0" x2="-50" y2="0" stroke="black" stroke-width="2"/>
                            <!-- 多位指示器(当位宽>1时显示) -->
                            <g id="multi-bit-indicator" style="display: none;">
                                <rect x="-45" y="15" width="40" height="8" fill="#006600" stroke="black" stroke-width="1" rx="2"/>
                                <text x="-25" y="20" font-family="Arial" font-size="6" text-anchor="middle" fill="white">MULTI</text>
                            </g>
                        </g>
                    </svg>
                `,
                'clock': `
                    <svg class="component-svg" viewBox="0 0 100 50" xmlns="http://www.w3.org/2000/svg">
                        <g id="clock-group" transform="translate(50, 25)">
                            <rect id="clock-bg" x="-40" y="-15" width="40" height="30" rx="5" fill="#FF6B35" stroke="black" stroke-width="2" class="clock-state"/>
                            <text id="clock-text" class="clock-text" x="-20" y="5" font-family="Arial" font-size="12" font-weight="bold" text-anchor="middle" fill="white">CLK</text>
                            <circle class="anchor output-anchor" data-anchor-type="output" cx="0" cy="0" r="5" fill="black"/>
                            <line x1="-5" y1="0" x2="0" y2="0" stroke="black" stroke-width="2"/>
                            <!-- 时钟波形图标 -->
                            <g transform="translate(-30, -8)">
                                <path d="M0,8 L0,0 L8,0 L8,8 L16,8 L16,0 L24,0 L24,8"
                                      fill="none" stroke="white" stroke-width="1.5"/>
                            </g>
                        </g>
                    </svg>
                `,
                'and-gate': `
                    <svg class="component-svg" viewBox="0 0 200 100" xmlns="http://www.w3.org/2000/svg">
                        <path d="M50,30 L120,30 A30,30 0 0,1 120,90 L50,90 Z" fill="none" stroke="black" stroke-width="2"/>
                        <text x="85" y="65" font-family="Arial" font-size="16">AND</text>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="45" r="5" fill="black"/>
                        <line x1="25" y1="45" x2="50" y2="45" stroke="black" stroke-width="2"/>
                        <text x="5" y="50" font-family="Arial" font-size="12">A</text>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="75" r="5" fill="black"/>
                        <line x1="25" y1="75" x2="50" y2="75" stroke="black" stroke-width="2"/>
                        <text x="5" y="80" font-family="Arial" font-size="12">B</text>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="60" r="5" fill="black"/>
                        <line x1="150" y1="60" x2="175" y2="60" stroke="black" stroke-width="2"/>
                        <text x="185" y="65" font-family="Arial" font-size="12">Y</text>
                    </svg>
                `,
                'not-gate': `
                    <svg class="component-svg" viewBox="0 0 200 100" xmlns="http://www.w3.org/2000/svg">
                        <path d="M50,30 L130,60 L50,90 Z" fill="none" stroke="black" stroke-width="2"/>
                        <circle cx="140" cy="60" r="8" fill="none" stroke="black" stroke-width="2"/>
                        <text x="85" y="65" font-family="Arial" font-size="16">NOT</text>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="60" r="5" fill="black"/>
                        <line x1="25" y1="60" x2="50" y2="60" stroke="black" stroke-width="2"/>
                        <text x="5" y="65" font-family="Arial" font-size="12">A</text>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="60" r="5" fill="black"/>
                        <line x1="148" y1="60" x2="175" y2="60" stroke="black" stroke-width="2"/>
                        <text x="185" y="65" font-family="Arial" font-size="12">Y</text>
                    </svg>
                `,
                'xor-gate': `
                    <svg class="component-svg" viewBox="0 0 200 100" xmlns="http://www.w3.org/2000/svg">
                        <path d="M50,30 Q120,30 150,60 Q120,90 50,90" fill="none" stroke="black" stroke-width="2"/>
                        <path d="M40,30 Q110,30 140,60 Q110,90 40,90" fill="none" stroke="black" stroke-width="2"/>
                        <line x1="50" y1="30" x2="50" y2="90" stroke="black" stroke-width="2"/>
                        <text x="85" y="65" font-family="Arial" font-size="16">XOR</text>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="45" r="5" fill="black"/>
                        <line x1="25" y1="45" x2="50" y2="45" stroke="black" stroke-width="2"/>
                        <text x="5" y="50" font-family="Arial" font-size="12">A</text>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="75" r="5" fill="black"/>
                        <line x1="25" y1="75" x2="50" y2="75" stroke="black" stroke-width="2"/>
                        <text x="5" y="80" font-family="Arial" font-size="12">B</text>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="60" r="5" fill="black"/>
                        <line x1="150" y1="60" x2="175" y2="60" stroke="black" stroke-width="2"/>
                        <text x="185" y="65" font-family="Arial" font-size="12">Y</text>
                    </svg>
                `,
                'nand-gate': `
                    <svg class="component-svg" viewBox="0 0 200 100" xmlns="http://www.w3.org/2000/svg">
                        <path d="M50,30 L120,30 A30,30 0 0,1 120,90 L50,90 Z" fill="none" stroke="black" stroke-width="2"/>
                        <circle cx="160" cy="60" r="8" fill="none" stroke="black" stroke-width="2"/>
                        <text x="85" y="65" font-family="Arial" font-size="16">NAND</text>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="45" r="5" fill="black"/>
                        <line x1="25" y1="45" x2="50" y2="45" stroke="black" stroke-width="2"/>
                        <text x="5" y="50" font-family="Arial" font-size="12">A</text>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="75" r="5" fill="black"/>
                        <line x1="25" y1="75" x2="50" y2="75" stroke="black" stroke-width="2"/>
                        <text x="5" y="80" font-family="Arial" font-size="12">B</text>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="60" r="5" fill="black"/>
                        <line x1="168" y1="60" x2="175" y2="60" stroke="black" stroke-width="2"/>
                        <text x="185" y="65" font-family="Arial" font-size="12">Y</text>
                    </svg>
                `,
                'd-flipflop': `
                    <svg class="component-svg" viewBox="0 0 200 120" xmlns="http://www.w3.org/2000/svg">
                        <rect x="50" y="20" width="100" height="80" fill="none" stroke="black" stroke-width="2"/>
                        <text x="100" y="45" font-family="Arial" font-size="16" text-anchor="middle">D</text>
                        <text x="100" y="85" font-family="Arial" font-size="16" text-anchor="middle">FF</text>

                        <!-- D输入 -->
                        <text x="5" y="45" font-family="Arial" font-size="12">D</text>
                        <line x1="25" y1="40" x2="50" y2="40" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="40" r="5" fill="black"/>

                        <!-- 时钟输入 -->
                        <text x="5" y="85" font-family="Arial" font-size="12">CLK</text>
                        <line x1="25" y1="80" x2="50" y2="80" stroke="black" stroke-width="2"/>
                        <path d="M45,75 L50,80 L45,85" fill="none" stroke="black" stroke-width="1"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="80" r="5" fill="black"/>

                        <!-- Q输出 -->
                        <text x="185" y="55" font-family="Arial" font-size="12">Q</text>
                        <line x1="150" y1="50" x2="175" y2="50" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="50" r="5" fill="black"/>

                        <!-- 非Q输出 -->
                        <text x="185" y="75" font-family="Arial" font-size="12">Q̄</text>
                        <line x1="150" y1="70" x2="175" y2="70" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="70" r="5" fill="black"/>
                    </svg>
                    `,
                'd-flipflop': `
                    <svg class="component-svg" viewBox="0 0 200 120" xmlns="http://www.w3.org/2000/svg">
                        <rect x="50" y="20" width="100" height="80" fill="#f0f0f0" stroke="black" stroke-width="2"/>
                        <text x="100" y="45" font-family="Arial" font-size="16" text-anchor="middle">D</text>
                        <text x="100" y="85" font-family="Arial" font-size="16" text-anchor="middle">FF</text>

                        <!-- D输入 -->
                        <text x="5" y="45" font-family="Arial" font-size="12">D</text>
                        <line x1="25" y1="40" x2="50" y2="40" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="40" r="5" fill="black"/>

                        <!-- 时钟输入 -->
                        <text x="5" y="85" font-family="Arial" font-size="12">CLK</text>
                        <line x1="25" y1="80" x2="50" y2="80" stroke="black" stroke-width="2"/>
                        <path d="M45,75 L50,80 L45,85" fill="none" stroke="black" stroke-width="1"/>
                        <circle class="anchor input-anchor clock-input" data-anchor-type="clock" cx="20" cy="80" r="5" fill="#0066cc"/>

                        <!-- Q输出 -->
                        <text x="185" y="55" font-family="Arial" font-size="12">Q</text>
                        <line x1="150" y1="50" x2="175" y2="50" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="50" r="5" fill="black"/>

                        <!-- 非Q输出 -->
                        <text x="185" y="75" font-family="Arial" font-size="12">Q̄</text>
                        <line x1="150" y1="70" x2="175" y2="70" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="70" r="5" fill="black"/>
                    </svg>
                `,
                'adder': `
                    <svg class="component-svg" viewBox="0 0 200 120" xmlns="http://www.w3.org/2000/svg">
                        <rect x="50" y="20" width="100" height="80" fill="#e8f4fd" stroke="black" stroke-width="2"/>
                        <text x="100" y="45" font-family="Arial" font-size="14" text-anchor="middle">ADD</text>
                        <text x="100" y="85" font-family="Arial" font-size="12" text-anchor="middle">加法器</text>

                        <!-- A输入 -->
                        <text x="5" y="45" font-family="Arial" font-size="12">A</text>
                        <line x1="25" y1="40" x2="50" y2="40" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="40" r="5" fill="black"/>

                        <!-- B输入 -->
                        <text x="5" y="65" font-family="Arial" font-size="12">B</text>
                        <line x1="25" y1="60" x2="50" y2="60" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="60" r="5" fill="black"/>

                        <!-- 进位输入 -->
                        <text x="5" y="85" font-family="Arial" font-size="12">Cin</text>
                        <line x1="25" y1="80" x2="50" y2="80" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="80" r="5" fill="black"/>

                        <!-- 和输出 -->
                        <text x="185" y="55" font-family="Arial" font-size="12">S</text>
                        <line x1="150" y1="50" x2="175" y2="50" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="50" r="5" fill="black"/>

                        <!-- 进位输出 -->
                        <text x="185" y="75" font-family="Arial" font-size="12">Cout</text>
                        <line x1="150" y1="70" x2="175" y2="70" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="70" r="5" fill="black"/>
                    </svg>
                `,
                'subtractor': `
                    <svg class="component-svg" viewBox="0 0 200 120" xmlns="http://www.w3.org/2000/svg">
                        <rect x="50" y="20" width="100" height="80" fill="#fde8e8" stroke="black" stroke-width="2"/>
                        <text x="100" y="45" font-family="Arial" font-size="14" text-anchor="middle">SUB</text>
                        <text x="100" y="85" font-family="Arial" font-size="12" text-anchor="middle">减法器</text>

                        <!-- A输入 -->
                        <text x="5" y="45" font-family="Arial" font-size="12">A</text>
                        <line x1="25" y1="40" x2="50" y2="40" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="40" r="5" fill="black"/>

                        <!-- B输入 -->
                        <text x="5" y="65" font-family="Arial" font-size="12">B</text>
                        <line x1="25" y1="60" x2="50" y2="60" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="60" r="5" fill="black"/>

                        <!-- 借位输入 -->
                        <text x="5" y="85" font-family="Arial" font-size="12">Bin</text>
                        <line x1="25" y1="80" x2="50" y2="80" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="80" r="5" fill="black"/>

                        <!-- 差输出 -->
                        <text x="185" y="55" font-family="Arial" font-size="12">D</text>
                        <line x1="150" y1="50" x2="175" y2="50" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="50" r="5" fill="black"/>

                        <!-- 借位输出 -->
                        <text x="185" y="75" font-family="Arial" font-size="12">Bout</text>
                        <line x1="150" y1="70" x2="175" y2="70" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="70" r="5" fill="black"/>
                    </svg>
                `,
                'divider': `
                    <svg class="component-svg" viewBox="0 0 200 120" xmlns="http://www.w3.org/2000/svg">
                        <rect x="50" y="20" width="100" height="80" fill="#f0e8fd" stroke="black" stroke-width="2"/>
                        <text x="100" y="45" font-family="Arial" font-size="14" text-anchor="middle">DIV</text>
                        <text x="100" y="85" font-family="Arial" font-size="12" text-anchor="middle">除法器</text>

                        <!-- 被除数输入 -->
                        <text x="5" y="45" font-family="Arial" font-size="12">A</text>
                        <line x1="25" y1="40" x2="50" y2="40" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="40" r="5" fill="black"/>

                        <!-- 除数输入 -->
                        <text x="5" y="75" font-family="Arial" font-size="12">B</text>
                        <line x1="25" y1="70" x2="50" y2="70" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="70" r="5" fill="black"/>

                        <!-- 商输出 -->
                        <text x="185" y="55" font-family="Arial" font-size="12">Q</text>
                        <line x1="150" y1="50" x2="175" y2="50" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="50" r="5" fill="black"/>

                        <!-- 余数输出 -->
                        <text x="185" y="75" font-family="Arial" font-size="12">R</text>
                        <line x1="150" y1="70" x2="175" y2="70" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="70" r="5" fill="black"/>
                    </svg>
                `,
                'complement': `
                    <svg class="component-svg" viewBox="0 0 200 100" xmlns="http://www.w3.org/2000/svg">
                        <rect x="50" y="30" width="100" height="60" fill="#e8fde8" stroke="black" stroke-width="2"/>
                        <text x="100" y="55" font-family="Arial" font-size="14" text-anchor="middle">COMP</text>
                        <text x="100" y="75" font-family="Arial" font-size="12" text-anchor="middle">求补器</text>

                        <!-- 输入 -->
                        <text x="5" y="65" font-family="Arial" font-size="12">A</text>
                        <line x1="25" y1="60" x2="50" y2="60" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="60" r="5" fill="black"/>

                        <!-- 输出 -->
                        <text x="185" y="65" font-family="Arial" font-size="12">Ā</text>
                        <line x1="150" y1="60" x2="175" y2="60" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="60" r="5" fill="black"/>
                    </svg>
                `,
                'jk-flipflop': `
                    <svg class="component-svg" viewBox="0 0 200 120" xmlns="http://www.w3.org/2000/svg">
                        <rect x="50" y="20" width="100" height="80" fill="#f0f0f0" stroke="black" stroke-width="2"/>
                        <text x="100" y="45" font-family="Arial" font-size="16" text-anchor="middle">JK</text>
                        <text x="100" y="85" font-family="Arial" font-size="16" text-anchor="middle">FF</text>

                        <!-- J输入 -->
                        <text x="5" y="35" font-family="Arial" font-size="12">J</text>
                        <line x1="25" y1="30" x2="50" y2="30" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="30" r="5" fill="black"/>

                        <!-- K输入 -->
                        <text x="5" y="55" font-family="Arial" font-size="12">K</text>
                        <line x1="25" y1="50" x2="50" y2="50" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="50" r="5" fill="black"/>

                        <!-- 时钟输入 -->
                        <text x="5" y="85" font-family="Arial" font-size="12">CLK</text>
                        <line x1="25" y1="80" x2="50" y2="80" stroke="black" stroke-width="2"/>
                        <path d="M45,75 L50,80 L45,85" fill="none" stroke="black" stroke-width="1"/>
                        <circle class="anchor input-anchor clock-input" data-anchor-type="clock" cx="20" cy="80" r="5" fill="#0066cc"/>

                        <!-- Q输出 -->
                        <text x="185" y="55" font-family="Arial" font-size="12">Q</text>
                        <line x1="150" y1="50" x2="175" y2="50" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="50" r="5" fill="black"/>

                        <!-- 非Q输出 -->
                        <text x="185" y="75" font-family="Arial" font-size="12">Q̄</text>
                        <line x1="150" y1="70" x2="175" y2="70" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="70" r="5" fill="black"/>
                    </svg>
                `,
                't-flipflop': `
                    <svg class="component-svg" viewBox="0 0 200 120" xmlns="http://www.w3.org/2000/svg">
                        <rect x="50" y="20" width="100" height="80" fill="#f0f0f0" stroke="black" stroke-width="2"/>
                        <text x="100" y="45" font-family="Arial" font-size="16" text-anchor="middle">T</text>
                        <text x="100" y="85" font-family="Arial" font-size="16" text-anchor="middle">FF</text>

                        <!-- T输入 -->
                        <text x="5" y="45" font-family="Arial" font-size="12">T</text>
                        <line x1="25" y1="40" x2="50" y2="40" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="40" r="5" fill="black"/>

                        <!-- 时钟输入 -->
                        <text x="5" y="85" font-family="Arial" font-size="12">CLK</text>
                        <line x1="25" y1="80" x2="50" y2="80" stroke="black" stroke-width="2"/>
                        <path d="M45,75 L50,80 L45,85" fill="none" stroke="black" stroke-width="1"/>
                        <circle class="anchor input-anchor clock-input" data-anchor-type="clock" cx="20" cy="80" r="5" fill="#0066cc"/>

                        <!-- Q输出 -->
                        <text x="185" y="55" font-family="Arial" font-size="12">Q</text>
                        <line x1="150" y1="50" x2="175" y2="50" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="50" r="5" fill="black"/>

                        <!-- 非Q输出 -->
                        <text x="185" y="75" font-family="Arial" font-size="12">Q̄</text>
                        <line x1="150" y1="70" x2="175" y2="70" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="70" r="5" fill="black"/>
                    </svg>
                `,
                'tp-flipflop': `
                    <svg class="component-svg" viewBox="0 0 200 120" xmlns="http://www.w3.org/2000/svg">
                        <rect x="50" y="20" width="100" height="80" fill="#f0f0f0" stroke="black" stroke-width="2"/>
                        <text x="100" y="45" font-family="Arial" font-size="16" text-anchor="middle">T'</text>
                        <text x="100" y="85" font-family="Arial" font-size="16" text-anchor="middle">FF</text>

                        <!-- T'输入 -->
                        <text x="5" y="45" font-family="Arial" font-size="12">T'</text>
                        <line x1="25" y1="40" x2="50" y2="40" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="40" r="5" fill="black"/>

                        <!-- 时钟输入 -->
                        <text x="5" y="85" font-family="Arial" font-size="12">CLK</text>
                        <line x1="25" y1="80" x2="50" y2="80" stroke="black" stroke-width="2"/>
                        <path d="M45,75 L50,80 L45,85" fill="none" stroke="black" stroke-width="1"/>
                        <circle class="anchor input-anchor clock-input" data-anchor-type="clock" cx="20" cy="80" r="5" fill="#0066cc"/>

                        <!-- Q输出 -->
                        <text x="185" y="55" font-family="Arial" font-size="12">Q</text>
                        <line x1="150" y1="50" x2="175" y2="50" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="50" r="5" fill="black"/>

                        <!-- 非Q输出 -->
                        <text x="185" y="75" font-family="Arial" font-size="12">Q̄</text>
                        <line x1="150" y1="70" x2="175" y2="70" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="70" r="5" fill="black"/>
                    </svg>
                `,
                'counter': `
                    <svg class="component-svg" viewBox="0 0 200 120" xmlns="http://www.w3.org/2000/svg">
                        <rect x="50" y="20" width="100" height="80" fill="#e8f4fd" stroke="black" stroke-width="2"/>
                        <text x="100" y="45" font-family="Arial" font-size="14" text-anchor="middle">COUNTER</text>
                        <text x="100" y="85" font-family="Arial" font-size="12" text-anchor="middle">计数器</text>

                        <!-- 时钟输入 -->
                        <text x="5" y="45" font-family="Arial" font-size="12">CLK</text>
                        <line x1="25" y1="40" x2="50" y2="40" stroke="black" stroke-width="2"/>
                        <path d="M45,35 L50,40 L45,45" fill="none" stroke="black" stroke-width="1"/>
                        <circle class="anchor input-anchor clock-input" data-anchor-type="clock" cx="20" cy="40" r="5" fill="#0066cc"/>

                        <!-- 复位输入 -->
                        <text x="5" y="75" font-family="Arial" font-size="12">RST</text>
                        <line x1="25" y1="70" x2="50" y2="70" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="70" r="5" fill="black"/>

                        <!-- 计数输出 -->
                        <text x="185" y="65" font-family="Arial" font-size="12">OUT</text>
                        <line x1="150" y1="60" x2="175" y2="60" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="60" r="5" fill="black"/>
                    </svg>
                `,
                'rs-latch': `
                    <svg class="component-svg" viewBox="0 0 200 120" xmlns="http://www.w3.org/2000/svg">
                        <rect x="50" y="20" width="100" height="80" fill="#f0f0f0" stroke="black" stroke-width="2"/>
                        <text x="100" y="45" font-family="Arial" font-size="16" text-anchor="middle">RS</text>
                        <text x="100" y="85" font-family="Arial" font-size="16" text-anchor="middle">LATCH</text>

                        <!-- R输入 -->
                        <text x="5" y="45" font-family="Arial" font-size="12">R</text>
                        <line x1="25" y1="40" x2="50" y2="40" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="40" r="5" fill="black"/>

                        <!-- S输入 -->
                        <text x="5" y="75" font-family="Arial" font-size="12">S</text>
                        <line x1="25" y1="70" x2="50" y2="70" stroke="black" stroke-width="2"/>
                        <circle class="anchor input-anchor" data-anchor-type="input" cx="20" cy="70" r="5" fill="black"/>

                        <!-- Q输出 -->
                        <text x="185" y="55" font-family="Arial" font-size="12">Q</text>
                        <line x1="150" y1="50" x2="175" y2="50" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="50" r="5" fill="black"/>

                        <!-- 非Q输出 -->
                        <text x="185" y="75" font-family="Arial" font-size="12">Q̄</text>
                        <line x1="150" y1="70" x2="175" y2="70" stroke="black" stroke-width="2"/>
                        <circle class="anchor output-anchor" data-anchor-type="output" cx="180" cy="70" r="5" fill="black"/>
                    </svg>
                `
            };

            // 集成线路组件的SVG模板
            if (window.CircuitComponents && window.CircuitComponents.svgs) {
                Object.assign(componentSvgs, window.CircuitComponents.svgs);
                console.log('已集成线路组件SVG模板:', Object.keys(window.CircuitComponents.svgs));
            } else {
                console.warn('CircuitComponents未加载或svgs未定义，将延迟集成');
                // 延迟集成，等待脚本加载完成
                setTimeout(() => {
                    if (window.CircuitComponents && window.CircuitComponents.svgs) {
                        Object.assign(componentSvgs, window.CircuitComponents.svgs);
                        window.componentSvgs = window.componentSvgs || {};
                        Object.assign(window.componentSvgs, componentSvgs);
                        console.log('延迟集成线路组件SVG模板成功:', Object.keys(window.CircuitComponents.svgs));
                    } else {
                        console.error('CircuitComponents仍未加载，请检查circuit-components.js文件');
                    }
                }, 100);
            }

            // 将基础组件SVG模板暴露到全局
            window.componentSvgs = window.componentSvgs || {};
            Object.assign(window.componentSvgs, componentSvgs);

            // 集成LED二极管组件的SVG模板
            if (window.LEDDiodeComponent) {
                componentSvgs['led-diode'] = window.LEDDiodeComponent.svg;
                window.componentSvgs['led-diode'] = window.LEDDiodeComponent.svg;
            }

            // 集成74LS138组件的SVG模板
            if (window.LS138Component && window.LS138Component.svg) {
                componentSvgs['74ls138'] = window.LS138Component.svg;
                window.componentSvgs['74ls138'] = window.LS138Component.svg;
                console.log('74LS138 SVG模板已集成');
            } else {
                // 延迟集成，等待74LS138脚本加载完成
                setTimeout(() => {
                    if (window.LS138Component && window.LS138Component.svg) {
                        componentSvgs['74ls138'] = window.LS138Component.svg;
                        window.componentSvgs['74ls138'] = window.LS138Component.svg;
                        console.log('延迟集成74LS138 SVG模板成功');
                    } else {
                        console.warn('74LS138组件SVG模板未找到，请检查74ls138.js文件');
                    }
                }, 300);
            }

            // 集成74LS151组件的SVG模板
            if (window.LS151Component && window.LS151Component.svg) {
                componentSvgs['74ls151'] = window.LS151Component.svg;
                window.componentSvgs['74ls151'] = window.LS151Component.svg;
                console.log('74LS151 SVG模板已集成');
            } else {
                // 延迟集成，等待74LS151脚本加载完成
                setTimeout(() => {
                    if (window.LS151Component && window.LS151Component.svg) {
                        componentSvgs['74ls151'] = window.LS151Component.svg;
                        window.componentSvgs['74ls151'] = window.LS151Component.svg;
                        console.log('延迟集成74LS151 SVG模板成功');
                    } else {
                        console.warn('74LS151组件SVG模板未找到，请检查74ls151.js文件');
                    }
                }, 300);
            }

            // 集成74LS161组件的SVG模板
            if (window.LS161Component && window.LS161Component.svg) {
                componentSvgs['74ls161'] = window.LS161Component.svg;
                window.componentSvgs['74ls161'] = window.LS161Component.svg;
                console.log('74LS161 SVG模板已集成');
            } else {
                // 延迟集成，等待74LS161脚本加载完成
                setTimeout(() => {
                    if (window.LS161Component && window.LS161Component.svg) {
                        componentSvgs['74ls161'] = window.LS161Component.svg;
                        window.componentSvgs['74ls161'] = window.LS161Component.svg;
                        console.log('延迟集成74LS161 SVG模板成功');
                    } else {
                        console.warn('74LS161组件SVG模板未找到，请检查74ls161.js文件');
                    }
                }, 300);
            }

            // 集成74LS175组件的SVG模板
            if (window.LS175Component && window.LS175Component.svg) {
                componentSvgs['74ls175'] = window.LS175Component.svg;
                window.componentSvgs['74ls175'] = window.LS175Component.svg;
                console.log('74LS175 SVG模板已集成');
            } else {
                // 延迟集成，等待74LS175脚本加载完成
                setTimeout(() => {
                    if (window.LS175Component && window.LS175Component.svg) {
                        componentSvgs['74ls175'] = window.LS175Component.svg;
                        window.componentSvgs['74ls175'] = window.LS175Component.svg;
                        console.log('延迟集成74LS175 SVG模板成功');
                    } else {
                        console.warn('74LS175组件SVG模板未找到，请检查74ls175.js文件');
                    }
                }, 300);
            }

            // 集成74LS160组件的SVG模板
            if (window.LS160Component && window.LS160Component.svg) {
                componentSvgs['74ls160'] = window.LS160Component.svg;
                window.componentSvgs['74ls160'] = window.LS160Component.svg;
                console.log('74LS160 SVG模板已集成');
            } else {
                // 延迟集成，等待74LS160脚本加载完成
                setTimeout(() => {
                    if (window.LS160Component && window.LS160Component.svg) {
                        componentSvgs['74ls160'] = window.LS160Component.svg;
                        window.componentSvgs['74ls160'] = window.LS160Component.svg;
                        console.log('延迟集成74LS160 SVG模板成功');
                    } else {
                        console.warn('74LS160组件SVG模板未找到，请检查74ls160.js文件');
                    }
                }, 300);
            }

            // 集成74LS280组件的SVG模板
            if (window.LS280Component && window.LS280Component.svg) {
                componentSvgs['74280'] = window.LS280Component.svg;
                window.componentSvgs['74280'] = window.LS280Component.svg;
                console.log('74LS280 SVG模板已集成');
            } else {
                // 延迟集成，等待74280脚本加载完成
                setTimeout(() => {
                    if (window.LS280Component && window.LS280Component.svg) {
                        componentSvgs['74280'] = window.LS280Component.svg;
                        window.componentSvgs['74280'] = window.LS280Component.svg;
                        console.log('延迟集成74LS280 SVG模板成功');
                    } else {
                        console.warn('74LS280组件SVG模板未找到，请检查74280.js文件');
                    }
                }, 300);
            }

            // 集成74139组件的SVG模板
            if (window.ls139Component && window.ls139Component['74139']) {
                componentSvgs['74139'] = window.ls139Component['74139'];
                window.componentSvgs['74139'] = window.ls139Component['74139'];
                console.log('74139 SVG模板已集成');
            } else {
                // 延迟集成，等待74139脚本加载完成
                setTimeout(() => {
                    if (window.ls139Component && window.ls139Component['74139']) {
                        componentSvgs['74139'] = window.ls139Component['74139'];
                        window.componentSvgs['74139'] = window.ls139Component['74139'];
                        console.log('延迟集成74139 SVG模板成功');
                    } else {
                        console.warn('74139组件SVG模板未找到，请检查74139.js文件');
                    }
                }, 300);
            }

            // 集成模N计数器组件的SVG模板
            if (window.ModNCounterComponent && window.ModNCounterComponent.svg) {
                componentSvgs['mod-n-counter'] = window.ModNCounterComponent.svg;
                window.componentSvgs['mod-n-counter'] = window.ModNCounterComponent.svg;
                console.log('模N计数器 SVG模板已集成');
            } else {
                // 延迟集成，等待模N计数器脚本加载完成
                setTimeout(() => {
                    if (window.ModNCounterComponent && window.ModNCounterComponent.svg) {
                        componentSvgs['mod-n-counter'] = window.ModNCounterComponent.svg;
                        window.componentSvgs['mod-n-counter'] = window.ModNCounterComponent.svg;
                        console.log('延迟集成模N计数器 SVG模板成功');
                    } else {
                        console.warn('模N计数器组件SVG模板未找到，请检查mod_n_counter.js文件');
                    }
                }, 300);
            }

            // 集成二进制异步计数器组件的SVG模板
            if (window.BinaryAsyncCounterComponent && window.BinaryAsyncCounterComponent.svg) {
                componentSvgs['binary-async-counter'] = window.BinaryAsyncCounterComponent.svg;
                window.componentSvgs['binary-async-counter'] = window.BinaryAsyncCounterComponent.svg;
                console.log('二进制异步计数器 SVG模板已集成');
            } else {
                // 延迟集成，等待异步计数器脚本加载完成
                setTimeout(() => {
                    if (window.BinaryAsyncCounterComponent && window.BinaryAsyncCounterComponent.svg) {
                        componentSvgs['binary-async-counter'] = window.BinaryAsyncCounterComponent.svg;
                        window.componentSvgs['binary-async-counter'] = window.BinaryAsyncCounterComponent.svg;
                        console.log('延迟集成异步计数器 SVG模板成功');
                    } else {
                        console.warn('异步计数器组件SVG模板未找到，请检查binary-async-counter.js文件');
                    }
                }, 300);
            }

            // 集成多数表决器组件的SVG模板
            if (window.MajorityVoterComponent && window.MajorityVoterComponent.svgs) {
                Object.assign(componentSvgs, window.MajorityVoterComponent.svgs);
                Object.assign(window.componentSvgs, window.MajorityVoterComponent.svgs);
                console.log('多数表决器 SVG模板已集成');
            } else {
                // 延迟集成，等待多数表决器脚本加载完成
                setTimeout(() => {
                    if (window.MajorityVoterComponent && window.MajorityVoterComponent.svgs) {
                        Object.assign(componentSvgs, window.MajorityVoterComponent.svgs);
                        Object.assign(window.componentSvgs, window.MajorityVoterComponent.svgs);
                        console.log('延迟集成多数表决器 SVG模板成功');
                    } else {
                        console.warn('多数表决器组件SVG模板未找到，请检查majority-voter.js文件');
                    }
                }, 300);
            }

            // 集成74LS153组件的SVG模板
            console.log('检查74LS153组件:', window.LS153Component);
            if (window.LS153Component && window.LS153Component.svg) {
                componentSvgs['74ls153'] = window.LS153Component.svg;
                window.componentSvgs['74ls153'] = window.LS153Component.svg;
                console.log('74LS153 SVG模板已集成');
            } else {
                // 延迟集成，等待74LS153脚本加载完成
                setTimeout(() => {
                    if (window.LS153Component && window.LS153Component.svg) {
                        componentSvgs['74ls153'] = window.LS153Component.svg;
                        window.componentSvgs['74ls153'] = window.LS153Component.svg;
                        console.log('延迟集成74LS153 SVG模板成功');
                    } else {
                        console.warn('74LS153组件SVG模板未找到，尝试更长延迟...');
                        // 尝试更长的延迟
                        setTimeout(() => {
                            if (window.LS153Component && window.LS153Component.svg) {
                                componentSvgs['74ls153'] = window.LS153Component.svg;
                                window.componentSvgs['74ls153'] = window.LS153Component.svg;
                                console.log('74LS153 SVG模板最终集成成功');
                            } else {
                                console.error('74LS153组件SVG模板最终未找到，请检查74ls153_final.js文件');
                            }
                        }, 1000);
                    }
                }, 300);
            }

            // 时序逻辑组件的SVG模板已经直接定义在componentSvgs中
            console.log('时序逻辑组件SVG模板已加载:', ['jk-flipflop', 't-flipflop', 'tp-flipflop', 'counter', 'binary-async-counter', 'rs-latch']);

            // 调试函数：检查组件加载状态
            function checkComponentStatus() {
                // Component status check removed

                // 检查基础组件
                const basicComponents = ['input', 'output', 'and-gate', 'or-gate', 'not-gate', 'xor-gate', 'nand-gate'];
                basicComponents.forEach(type => {
                    // Component check removed
                });

                // 检查时序逻辑组件
                const sequentialComponents = ['d-flipflop', 'jk-flipflop', 't-flipflop', 'tp-flipflop', 'counter', 'rs-latch'];
                sequentialComponents.forEach(type => {
                    // Component check removed
                });

                // 检查运算器组件
                const arithmeticComponents = ['adder', 'subtractor', 'divider', 'complement'];
                arithmeticComponents.forEach(type => {
                    // Component check removed
                });

                // 检查其他组件
                const otherComponents = ['clock', 'push-button', 'switch', 'led-diode'];
                otherComponents.forEach(type => {
                    // Component check removed
                });

                // 检查线路组件
                const circuitComponents = ['pin', 'splitter', 'probe', 'power', 'ground'];
                circuitComponents.forEach(type => {
                    // Component check removed
                });


            }

            // 延迟执行状态检查
            setTimeout(checkComponentStatus, 1000);

            // 确保页面加载时隐藏所有磁吸指示器
            setTimeout(() => {
                magneticSnap.hideAllIndicators();
            }, 100);

            // 逻辑门计算函数
            const logicFunctions = {
                'and-gate': (inputs) => inputs.reduce((a, b) => a && b, true),
                'or-gate': (inputs) => inputs.reduce((a, b) => a || b, false),
                'not-gate': (inputs) => !inputs[0],
                'xor-gate': (inputs) => inputs[0] !== inputs[1],
                'nand-gate': (inputs) => !inputs.reduce((a, b) => a && b, true),
                'd-flipflop': (inputs) => {
                    // D触发器的逻辑由时钟边沿触发处理，这里返回当前状态
                    // 实际的状态更新在 processDFlipFlop 中处理
                    return inputs[0] || 0; // 返回D输入状态作为默认
                },
                'adder': (inputs) => {
                    // 全加器逻辑: A + B + Cin
                    const a = inputs[0] || 0;
                    const b = inputs[1] || 0;
                    const cin = inputs[2] || 0;
                    const sum = a + b + cin;
                    return {
                        sum: sum % 2,      // 和输出 (S)
                        carry: Math.floor(sum / 2)  // 进位输出 (Cout)
                    };
                },
                'subtractor': (inputs) => {
                    // 全减器逻辑: A - B - Bin
                    const a = inputs[0] || 0;
                    const b = inputs[1] || 0;
                    const bin = inputs[2] || 0;
                    const diff = a - b - bin;
                    return {
                        difference: diff >= 0 ? diff : (diff + 2),  // 差输出 (D)
                        borrow: diff < 0 ? 1 : 0  // 借位输出 (Bout)
                    };
                },
                'divider': (inputs) => {
                    // 除法器逻辑: A / B
                    const a = inputs[0] || 0;
                    const b = inputs[1] || 0; // 不设置默认值，保持原始输入
                    if (b === 0) {
                        return { quotient: 0, remainder: 0 }; // 除零保护
                    }
                    return {
                        quotient: Math.floor(a / b),  // 商输出 (Q)
                        remainder: a % b  // 余数输出 (R)
                    };
                },
                'complement': (inputs) => {
                    // 求补器逻辑: ~A (按位取反)
                    const a = inputs[0] || 0;
                    return 1 - a; // 对于单位逻辑，取反就是1-a
                },
                'led-diode': (inputs) => {
                    // LED二极管逻辑：直接返回输入状态，用于显示
                    return inputs[0] || 0;
                },
                'jk-flipflop': (inputs) => {
                    // JK触发器的逻辑由时钟边沿触发处理，这里返回当前状态
                    // inputs[0] = J, inputs[1] = K, inputs[2] = CLK
                    return inputs[0] || 0;
                },
                't-flipflop': (inputs) => {
                    // T触发器的逻辑由时钟边沿触发处理，这里返回当前状态
                    // inputs[0] = T, inputs[1] = CLK
                    return inputs[0] || 0;
                },
                'tp-flipflop': (inputs) => {
                    // T'触发器的逻辑由时钟边沿触发处理，这里返回当前状态
                    // inputs[0] = T', inputs[1] = CLK
                    return inputs[0] || 0;
                },
                'counter': (inputs) => {
                    // 计数器的逻辑由时钟边沿触发处理，这里返回当前状态
                    // inputs[0] = CLK, inputs[1] = RST
                    return inputs[0] || 0;
                },
                'rs-latch': (inputs) => {
                    // RS锁存器逻辑：R=1时复位，S=1时置位，R=S=1时禁止
                    const r = inputs[0] || 0; // R输入
                    const s = inputs[1] || 0; // S输入
                    if (r && s) return 0; // 禁止状态，输出0
                    if (r) return 0; // 复位，输出0
                    if (s) return 1; // 置位，输出1
                    // 保持状态，返回之前的状态
                    return inputs[0] || 0;
                },
                '74ls138': (inputs) => {
                    // 74LS138 3线-8线译码器逻辑
                    const A2 = inputs.A2 || 0;
                    const A1 = inputs.A1 || 0;
                    const A0 = inputs.A0 || 0;
                    const G1 = inputs.G1 || 0;
                    const G2A = inputs.G2A || 0;  // 低电平有效
                    const G2B = inputs.G2B || 0;  // 低电平有效

                    // 检查使能条件：G1=1 且 G2A=0 且 G2B=0
                    const enableCondition = (G1 === 1) && (G2A === 0) && (G2B === 0);

                    // 初始化所有输出为1（高电平，因为输出是低电平有效）
                    let outputs = {
                        Y0: 1, Y1: 1, Y2: 1, Y3: 1,
                        Y4: 1, Y5: 1, Y6: 1, Y7: 1
                    };

                    if (enableCondition) {
                        // 计算选择的输出线
                        const selectedOutput = (A2 << 2) | (A1 << 1) | A0;

                        // 只有选中的输出线为0，其他保持1
                        switch(selectedOutput) {
                            case 0: outputs.Y0 = 0; break;
                            case 1: outputs.Y1 = 0; break;
                            case 2: outputs.Y2 = 0; break;
                            case 3: outputs.Y3 = 0; break;
                            case 4: outputs.Y4 = 0; break;
                            case 5: outputs.Y5 = 0; break;
                            case 6: outputs.Y6 = 0; break;
                            case 7: outputs.Y7 = 0; break;
                        }
                    }

                    return outputs;
                },
                '74ls151': (inputs) => {
                    // 74LS151 8选1数据选择器逻辑
                    const C = inputs.C || 0;  // 地址输入C (MSB)
                    const B = inputs.B || 0;  // 地址输入B
                    const A = inputs.A || 0;  // 地址输入A (LSB)
                    const S = inputs.S || 0;  // 使能端 (低电平有效)

                    // 数据输入D0-D7
                    const dataInputs = [
                        inputs.D0 || 0, inputs.D1 || 0, inputs.D2 || 0, inputs.D3 || 0,
                        inputs.D4 || 0, inputs.D5 || 0, inputs.D6 || 0, inputs.D7 || 0
                    ];

                    let outputs = { Y: 0, W: 1 };

                    // 使能控制：当S̅=0时，数据选择器正常工作；当S̅=1时，输出Y为低电平，W̅为高电平
                    if (S === 0) {
                        // 根据地址输入CBA选择对应的数据输入
                        const selectedIndex = (C << 2) | (B << 1) | A;
                        const selectedData = dataInputs[selectedIndex];

                        outputs.Y = selectedData;           // Y输出选中的数据
                        outputs.W = selectedData ? 0 : 1;   // W̅输出选中数据的反相
                    } else {
                        // 使能端为高电平时，输出Y为低电平，W̅为高电平
                        outputs.Y = 0;
                        outputs.W = 1;
                    }

                    return outputs;
                }
            };

            // 将logicFunctions暴露到全局，以便外部组件可以集成其逻辑
            window.logicFunctions = logicFunctions;

            // 集成74LS138组件的逻辑函数
            if (window.LS138Component && window.LS138Component.logic) {
                logicFunctions['74ls138'] = window.LS138Component.logic;
                console.log('74LS138逻辑函数已集成');
            } else {
                // 延迟集成，等待74LS138脚本加载完成
                setTimeout(() => {
                    if (window.LS138Component && window.LS138Component.logic) {
                        logicFunctions['74ls138'] = window.LS138Component.logic;
                        window.logicFunctions['74ls138'] = window.LS138Component.logic;
                        console.log('延迟集成74LS138逻辑函数成功');
                    } else {
                        console.warn('74LS138组件逻辑函数未找到，请检查74ls138.js文件');
                    }
                }, 200);
            }

            // 集成74LS151组件的逻辑函数
            if (window.LS151Component && window.LS151Component.logic) {
                logicFunctions['74ls151'] = window.LS151Component.logic;
                console.log('74LS151逻辑函数已集成');
            } else {
                // 延迟集成，等待74LS151脚本加载完成
                setTimeout(() => {
                    if (window.LS151Component && window.LS151Component.logic) {
                        logicFunctions['74ls151'] = window.LS151Component.logic;
                        window.logicFunctions['74ls151'] = window.LS151Component.logic;
                        console.log('延迟集成74LS151逻辑函数成功');
                    } else {
                        console.warn('74LS151组件逻辑函数未找到，请检查74ls151.js文件');
                    }
                }, 200);
            }

            // 集成74LS161组件的逻辑函数
            if (window.LS161Component && window.LS161Component.logic) {
                logicFunctions['74ls161'] = window.LS161Component.logic;
                console.log('74LS161逻辑函数已集成');
            } else {
                // 延迟集成，等待74LS161脚本加载完成
                setTimeout(() => {
                    if (window.LS161Component && window.LS161Component.logic) {
                        logicFunctions['74ls161'] = window.LS161Component.logic;
                        window.logicFunctions['74ls161'] = window.LS161Component.logic;
                        console.log('延迟集成74LS161逻辑函数成功');
                    } else {
                        console.warn('74LS161组件逻辑函数未找到，请检查74ls161.js文件');
                    }
                }, 200);
            }

            // 集成74LS175组件的逻辑函数
            if (window.LS175Component && window.LS175Component.logic) {
                logicFunctions['74ls175'] = window.LS175Component.logic;
                console.log('74LS175逻辑函数已集成');
            } else {
                // 延迟集成，等待74LS175脚本加载完成
                setTimeout(() => {
                    if (window.LS175Component && window.LS175Component.logic) {
                        logicFunctions['74ls175'] = window.LS175Component.logic;
                        window.logicFunctions['74ls175'] = window.LS175Component.logic;
                        console.log('延迟集成74LS175逻辑函数成功');
                    } else {
                        console.warn('74LS175组件逻辑函数未找到，请检查74ls175.js文件');
                    }
                }, 200);
            }

            // 集成74LS160组件的逻辑函数
            if (window.LS160Component && window.LS160Component.logic) {
                logicFunctions['74ls160'] = window.LS160Component.logic;
                console.log('74LS160逻辑函数已集成');
            } else {
                // 延迟集成，等待74LS160脚本加载完成
                setTimeout(() => {
                    if (window.LS160Component && window.LS160Component.logic) {
                        logicFunctions['74ls160'] = window.LS160Component.logic;
                        window.logicFunctions['74ls160'] = window.LS160Component.logic;
                        console.log('延迟集成74LS160逻辑函数成功');
                    } else {
                        console.warn('74LS160组件逻辑函数未找到，请检查74ls160.js文件');
                    }
                }, 200);
            }

            // 集成74LS280组件的逻辑函数
            if (window.LS280Component && window.LS280Component.logic) {
                logicFunctions['74280'] = window.LS280Component.logic;
                console.log('74LS280逻辑函数已集成');
            } else {
                // 延迟集成，等待74280脚本加载完成
                setTimeout(() => {
                    if (window.LS280Component && window.LS280Component.logic) {
                        logicFunctions['74280'] = window.LS280Component.logic;
                        window.logicFunctions['74280'] = window.LS280Component.logic;
                        console.log('延迟集成74LS280逻辑函数成功');
                    } else {
                        console.warn('74LS280组件逻辑函数未找到，请检查74280.js文件');
                    }
                }, 200);
            }

            // 集成74139组件的逻辑函数
            if (window.ls139Logic && window.ls139Logic['74139']) {
                logicFunctions['74139'] = window.ls139Logic['74139'];
                console.log('74139逻辑函数已集成');
            } else {
                // 延迟集成，等待74139脚本加载完成
                setTimeout(() => {
                    if (window.ls139Logic && window.ls139Logic['74139']) {
                        logicFunctions['74139'] = window.ls139Logic['74139'];
                        window.logicFunctions['74139'] = window.ls139Logic['74139'];
                        console.log('延迟集成74139逻辑函数成功');
                    } else {
                        console.warn('74139组件逻辑函数未找到，请检查74139.js文件');
                    }
                }, 200);
            }

            // 集成模N计数器组件的逻辑函数
            if (window.ModNCounterComponent && window.ModNCounterComponent.logic) {
                logicFunctions['mod-n-counter'] = window.ModNCounterComponent.logic;
                console.log('模N计数器逻辑函数已集成');
            } else {
                // 延迟集成，等待模N计数器脚本加载完成
                setTimeout(() => {
                    if (window.ModNCounterComponent && window.ModNCounterComponent.logic) {
                        logicFunctions['mod-n-counter'] = window.ModNCounterComponent.logic;
                        window.logicFunctions['mod-n-counter'] = window.ModNCounterComponent.logic;
                        console.log('延迟集成模N计数器逻辑函数成功');
                    } else {
                        console.warn('模N计数器组件逻辑函数未找到，请检查mod_n_counter.js文件');
                    }
                }, 200);
            }

            // 集成二进制异步计数器组件的逻辑函数
            if (window.BinaryAsyncCounterComponent && window.BinaryAsyncCounterComponent.logic) {
                logicFunctions['binary-async-counter'] = window.BinaryAsyncCounterComponent.logic;
                console.log('二进制异步计数器逻辑函数已集成');
            } else {
                // 延迟集成，等待异步计数器脚本加载完成
                setTimeout(() => {
                    if (window.BinaryAsyncCounterComponent && window.BinaryAsyncCounterComponent.logic) {
                        logicFunctions['binary-async-counter'] = window.BinaryAsyncCounterComponent.logic;
                        window.logicFunctions['binary-async-counter'] = window.BinaryAsyncCounterComponent.logic;
                        console.log('延迟集成异步计数器逻辑函数成功');
                    } else {
                        console.warn('异步计数器组件逻辑函数未找到，请检查binary-async-counter.js文件');
                    }
                }, 200);
            }

            // 集成多数表决器组件的逻辑函数
            if (window.MajorityVoterComponent && window.MajorityVoterComponent.logic) {
                Object.assign(logicFunctions, window.MajorityVoterComponent.logic);
                console.log('多数表决器逻辑函数已集成');
            } else {
                // 延迟集成，等待多数表决器脚本加载完成
                setTimeout(() => {
                    if (window.MajorityVoterComponent && window.MajorityVoterComponent.logic) {
                        Object.assign(logicFunctions, window.MajorityVoterComponent.logic);
                        Object.assign(window.logicFunctions, window.MajorityVoterComponent.logic);
                        console.log('延迟集成多数表决器逻辑函数成功');
                    } else {
                        console.warn('多数表决器组件逻辑函数未找到，请检查majority-voter.js文件');
                    }
                }, 200);
            }

            // 集成74LS153组件的逻辑函数
            if (window.LS153Component && window.LS153Component.logic) {
                logicFunctions['74ls153'] = window.LS153Component.logic;
                console.log('74LS153逻辑函数已集成');
            } else {
                // 延迟集成，等待74LS153脚本加载完成
                setTimeout(() => {
                    if (window.LS153Component && window.LS153Component.logic) {
                        logicFunctions['74ls153'] = window.LS153Component.logic;
                        window.logicFunctions['74ls153'] = window.LS153Component.logic;
                        console.log('延迟集成74LS153逻辑函数成功');
                    } else {
                        console.warn('74LS153组件逻辑函数未找到，请检查74ls153_final.js文件');
                    }
                }, 200);
            }

            // 多位数据处理的辅助函数
            
            // 获取组件的位宽
            function getComponentBitWidth(componentId) {
                return componentBitWidth.get(componentId) || 1;
            }

            // 设置组件的位宽
            function setComponentBitWidth(componentId, width) {
                componentBitWidth.set(componentId, width);
                
                // 调整数据数组长度
                let data = componentMultiBitData.get(componentId) || [0];
                if (width > data.length) {
                    // 扩展数组，新位填0
                    data = [...data, ...Array(width - data.length).fill(0)];
                } else if (width < data.length) {
                    // 截取数组
                    data = data.slice(0, width);
                }
                componentMultiBitData.set(componentId, data);
                
                // 更新状态为组合状态
                updateComponentState(componentId);
            }

            // 获取组件的多位数据
            function getComponentMultiBitData(componentId) {
                return componentMultiBitData.get(componentId) || [0];
            }

            // 设置组件某一位的数据
            function setComponentBitData(componentId, bitIndex, value) {
                let data = getComponentMultiBitData(componentId);
                if (bitIndex >= 0 && bitIndex < data.length) {
                    data[bitIndex] = value ? 1 : 0;
                    componentMultiBitData.set(componentId, data);
                    updateComponentState(componentId);
                }
            }

            // 设置整个多位数据
            function setComponentMultiBitData(componentId, dataArray) {
                componentMultiBitData.set(componentId, [...dataArray]);
                updateComponentState(componentId);
            }

            // 更新组件的综合状态（从多位数据计算）
            function updateComponentState(componentId) {
                const data = getComponentMultiBitData(componentId);
                // 将多位数据转换为十进制数值
                const decimalValue = data.reduce((acc, bit, index) => {
                    return acc + bit * Math.pow(2, data.length - 1 - index);
                }, 0);
                componentStates.set(componentId, decimalValue);
            }

            // 获取组件的二进制字符串表示
            function getComponentBinaryString(componentId) {
                const data = getComponentMultiBitData(componentId);
                return data.join('');
            }

            // 获取组件的十六进制字符串表示
            function getComponentHexString(componentId) {
                const decimalValue = componentStates.get(componentId) || 0;
                return '0x' + decimalValue.toString(16).toUpperCase().padStart(Math.ceil(getComponentBitWidth(componentId) / 4), '0');
            }

            // 更新端口显示
            function updatePortDisplay(componentId) {
                const component = canvas.querySelector(`[data-id="${componentId}"]`);
                if (!component) return;
                
                const bitWidth = getComponentBitWidth(componentId);
                const data = getComponentMultiBitData(componentId);
                const decimalValue = componentStates.get(componentId) || 0;
                
                // 更新位宽标签
                const widthLabel = component.querySelector('#input-width-label') || component.querySelector('#output-width-label');
                if (widthLabel) {
                    widthLabel.textContent = `${bitWidth}bit`;
                }
                
                // 更新数据显示
                const textElement = component.querySelector('#input-text') || component.querySelector('#output-text');
                if (textElement) {
                    if (bitWidth === 1) {
                        textElement.textContent = data[0].toString();
                    } else if (bitWidth <= 4) {
                        // 小于等于4位显示二进制
                        textElement.textContent = getComponentBinaryString(componentId);
                    } else {
                        // 大于4位显示十进制
                        textElement.textContent = decimalValue.toString();
                    }
                }
                
                // 更新背景颜色（根据是否为0）
                const bgElement = component.querySelector('#input-bg') || component.querySelector('#output-bg');
                if (bgElement) {
                    bgElement.classList.remove('state-0', 'state-1');
                    bgElement.classList.add(decimalValue === 0 ? 'state-0' : 'state-1');
                }
                
                // 显示/隐藏多位指示器
                const indicator = component.querySelector('#multi-bit-indicator');
                if (indicator) {
                    indicator.style.display = bitWidth > 1 ? 'block' : 'none';
                }
            }

            // 初始化外部组件
            if (typeof initializePushButtonComponent === 'function') {
                initializePushButtonComponent(componentSvgs, logicFunctions);
            }
            if (typeof initializeSwitchComponent === 'function') {
                initializeSwitchComponent(componentSvgs, logicFunctions);
            }


            // 快捷工具栏事件处理
            toolbarItems.forEach(item => {
                item.addEventListener('click', function() {
                    const tool = this.getAttribute('data-tool');

                    // 移除所有active状态
                    toolbarItems.forEach(t => t.classList.remove('active'));

                    if (tool === 'text') {
                        // 文字工具逻辑
                        this.classList.add('active');
                        currentTool = 'text';
                        canvas.style.cursor = 'text';
                        console.log('文字工具已激活 - 点击画布添加文字');
                    } else if (['input', 'output', 'and-gate', 'or-gate', 'not-gate', 'xor-gate', 'nand-gate', 'd-flipflop', 'jk-flipflop', 't-flipflop', 'tp-flipflop', '74ls175', 'counter', 'binary-async-counter', 'rs-latch', 'adder', 'subtractor', 'divider', 'complement', 'push-button', 'switch', 'led-diode', 'clock', 'pin', 'splitter', 'probe', 'power', 'ground', 'majority-voter-3', 'majority-voter-5', 'majority-voter-7', '74ls153'].includes(tool)) {
                        // 元件工具
                        this.classList.add('active');
                        currentTool = tool;
                        canvas.style.cursor = 'crosshair';

                        // 创建元件
                        createComponentFromToolbar(tool);
                    }
                });
            });

            // 从快捷栏创建元件的函数
            function createComponentFromToolbar(type) {
                if (!componentSvgs[type]) return;

                // 创建元件容器
                const componentDiv = document.createElement('div');
                componentDiv.className = 'component';
                componentDiv.style.left = '150px';  // 在画布中央位置
                componentDiv.style.top = '150px';
                componentDiv.innerHTML = componentSvgs[type];
                componentDiv.dataset.type = type;
                componentDiv.dataset.id = Date.now(); // 唯一ID
                canvas.appendChild(componentDiv);

                // 初始化状态（复用原有逻辑）
                initializeComponent(componentDiv, type);

                // 重置工具状态
                toolbarItems.forEach(t => t.classList.remove('active'));
                currentTool = null;
                canvas.style.cursor = 'default';
            }

            // 提取元件初始化逻辑为独立函数
            function initializeComponent(componentDiv, type) {
                // 初始化状态
                if (type === 'input' || type === 'output') {
                    const id = componentDiv.dataset.id;
                    componentStates.set(id, 0);
                    // 设置默认位宽为1位
                    componentBitWidth.set(id, 1);
                    // 初始化多位数据为0
                    componentMultiBitData.set(id, [0]);
                    // 更新显示
                    updatePortDisplay(id);
                    
                    // 设置光标和提示
                    componentDiv.style.cursor = 'pointer';
                    componentDiv.title = `${type === 'input' ? '输入' : '输出'}端口 - 双击配置位宽和数据值`;
                    
                    // 添加双击配置事件
                    componentDiv.addEventListener('dblclick', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        if (type === 'input') {
                            showInputPortConfigDialog(componentDiv);
                        } else {
                            showOutputPortConfigDialog(componentDiv);
                        }
                    });
                } else if (type === 'clock') {
                    const id = componentDiv.dataset.id;
                    componentStates.set(id, 0);
                    clockPreviousStates.set(id, 0);
                    startClockSignal(componentDiv);
                } else if (type === 'd-flipflop') {
                    const id = componentDiv.dataset.id;
                    componentStates.set(id, 0);
                    sequentialElements.set(id, {
                        q: 0,
                        qBar: 1,
                        lastD: 0,
                        lastClock: 0
                    });
                    updateDFlipFlopDisplay(componentDiv, 0, 1);
                } else if (type === 'jk-flipflop') {
                    // JK触发器初始化
                    const id = componentDiv.dataset.id;
                    componentStates.set(id, 0);
                    sequentialElements.set(id, {
                        q: 0,
                        qBar: 1,
                        lastJ: 0,
                        lastK: 0,
                        lastClock: 0
                    });
                    if (window.JKFlipFlopComponent && window.JKFlipFlopComponent.initialize) {
                        window.JKFlipFlopComponent.initialize(componentDiv);
                    }
                } else if (type === 't-flipflop') {
                    // T触发器初始化
                    const id = componentDiv.dataset.id;
                    componentStates.set(id, 0);
                    sequentialElements.set(id, {
                        q: 0,
                        qBar: 1,
                        lastT: 0,
                        lastClock: 0
                    });
                    if (window.TFlipFlopComponent && window.TFlipFlopComponent.initialize) {
                        window.TFlipFlopComponent.initialize(componentDiv);
                    }
                } else if (type === 'tp-flipflop') {
                    // T'触发器初始化
                    const id = componentDiv.dataset.id;
                    componentStates.set(id, 0);
                    sequentialElements.set(id, {
                        q: 0,
                        qBar: 1,
                        lastT: 0,
                        lastClock: 0
                    });
                    if (window.TPFlipFlopComponent && window.TPFlipFlopComponent.initialize) {
                        window.TPFlipFlopComponent.initialize(componentDiv);
                    }
                } else if (type === 'counter') {
                    // 计数器初始化
                    const id = componentDiv.dataset.id;

                    // 设置默认配置
                    if (!componentDiv.dataset.maxValue) {
                        componentDiv.dataset.maxValue = '15'; // 默认4位计数器（0-15）
                    }
                    if (!componentDiv.dataset.overflowAction) {
                        componentDiv.dataset.overflowAction = 'wrap'; // 默认重新计数
                    }

                    componentStates.set(id, 0);
                    sequentialElements.set(id, {
                        count: 0,
                        carry: 0,
                        lastClock: 0,
                        maxValue: parseInt(componentDiv.dataset.maxValue),
                        overflowAction: componentDiv.dataset.overflowAction
                    });

                    console.log(`计数器 ${id} 初始化: 最大值=${componentDiv.dataset.maxValue}, 溢出行为=${componentDiv.dataset.overflowAction}`);

                    if (window.CounterComponent && window.CounterComponent.initialize) {
                        window.CounterComponent.initialize(componentDiv);
                    }
                } else if (type === 'rs-latch') {
                    // RS锁存器初始化
                    const id = componentDiv.dataset.id;
                    componentStates.set(id, 0);
                    sequentialElements.set(id, {
                        q: 0,
                        qBar: 1,
                        lastR: 0,
                        lastS: 0
                    });
                    if (window.RSLatchComponent && window.RSLatchComponent.initialize) {
                        window.RSLatchComponent.initialize(componentDiv);
                    }
                } else if (type === 'push-button') {
                    const id = componentDiv.dataset.id;
                    componentStates.set(id, 0);
                    // 设置默认配置为高电平触发
                    if (typeof setButtonConfig === 'function') {
                        setButtonConfig(id, { trigger: 'high' });
                    }
                } else if (type === 'switch') {
                    const id = componentDiv.dataset.id;
                    componentStates.set(id, 0);
                    // 初始化开关状态
                    if (typeof setSwitchState === 'function') {
                        setSwitchState(id, 0);
                    }
                } else if (['adder', 'subtractor', 'divider', 'complement'].includes(type)) {
                    // 运算器组件初始化
                    const id = componentDiv.dataset.id;
                    componentStates.set(id, { sum: 0, carry: 0, diff: 0, borrow: 0, quotient: 0, remainder: 0, complement: 0 });

                } else if (type === 'led-diode') {
                    // LED二极管组件初始化
                    const id = componentDiv.dataset.id;
                    componentStates.set(id, 0);

                    // 不调用外部组件的初始化，避免添加不需要的事件监听器
                    // 直接设置LED的基本属性
                    componentDiv.dataset.bitWidth = '1';
                    componentDiv.dataset.ledColor = '#ff0000';
                    componentDiv.style.cursor = 'pointer';

                    // 只添加双击事件打开配置对话框
                    componentDiv.addEventListener('dblclick', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        if (window.showSimpleLEDColorDialog) {
                            window.showSimpleLEDColorDialog(componentDiv);
                        } else {
                            showLEDConfigDialog(componentDiv);
                        }
                    });

                    // 初始化LED显示状态（确保初始为熄灭状态）
                    updateLEDDisplay(componentDiv, 0);
                } else if (type === '74ls138') {
                    // 74LS138译码器初始化
                    const id = componentDiv.dataset.id;
                    // 初始化输出状态（所有输出默认为1，因为没有使能）
                    componentStates.set(id, {
                        Y0: 1, Y1: 1, Y2: 1, Y3: 1,
                        Y4: 1, Y5: 1, Y6: 1, Y7: 1
                    });

                    // 调用74LS138组件的初始化函数
                    if (window.initialize74LS138Component) {
                        window.initialize74LS138Component(componentDiv, type);
                    } else if (window.LS138Component && window.LS138Component.initialize) {
                        window.LS138Component.initialize(componentDiv, type);
                    }
                } else if (type === '74ls151') {
                    // 74LS151数据选择器初始化
                    const id = componentDiv.dataset.id;
                    // 初始化输出状态
                    componentStates.set(id, {
                        C: 0, B: 0, A: 0, S: 0,
                        D0: 0, D1: 0, D2: 0, D3: 0,
                        D4: 0, D5: 0, D6: 0, D7: 0,
                        Y: 0, W: 1
                    });

                    // 调用74LS151组件的初始化函数
                    if (window.initialize74LS151Component) {
                        window.initialize74LS151Component(componentDiv, type);
                    } else if (window.LS151Component && window.LS151Component.initialize) {
                        window.LS151Component.initialize(componentDiv, type);
                    }
                } else if (type === '74ls161') {
                    // 74LS161同步计数器初始化
                    const id = componentDiv.dataset.id;
                    // 初始化输出状态
                    componentStates.set(id, {
                        RD: 1, CP: 0, LD: 1, EP: 0, ET: 0,
                        A0: 0, A1: 0, A2: 0, A3: 0,
                        Q0: 0, Q1: 0, Q2: 0, Q3: 0,
                        RCO: 0, prevCP: 0
                    });

                    // 调用74LS161组件的初始化函数
                    if (window.initialize74LS161Component) {
                        window.initialize74LS161Component(componentDiv, type);
                    } else if (window.LS161Component && window.LS161Component.initialize) {
                        window.LS161Component.initialize(componentDiv, type);
                    }
                } else if (type === '74ls175') {
                    // 74LS175四位并行寄存器初始化
                    const id = componentDiv.dataset.id;
                    // 初始化输出状态
                    componentStates.set(id, {
                        CLR: 1, CLK: 0,
                        D1: 0, D2: 0, D3: 0, D4: 0,
                        Q1: 0, Q2: 0, Q3: 0, Q4: 0,
                        NQ1: 1, NQ2: 1, NQ3: 1, NQ4: 1,
                        prevCLK: 0
                    });

                    // 调用74LS175组件的初始化函数
                    if (window.initialize74LS175Component) {
                        window.initialize74LS175Component(componentDiv, type);
                    } else if (window.LS175Component && window.LS175Component.initialize) {
                        window.LS175Component.initialize(componentDiv, type);
                    }
                } else if (type === '74ls160') {
                    // 74LS160同步十进制计数器初始化
                    const id = componentDiv.dataset.id;
                    // 初始化输出状态
                    componentStates.set(id, {
                        RD: 1, CP: 0, LD: 1, EP: 0, ET: 0,
                        A0: 0, A1: 0, A2: 0, A3: 0,
                        Q0: 0, Q1: 0, Q2: 0, Q3: 0,
                        RCO: 0, prevCP: 0
                    });

                    // 调用74LS160组件的初始化函数
                    if (window.initialize74LS160Component) {
                        window.initialize74LS160Component(componentDiv, type);
                    } else if (window.LS160Component && window.LS160Component.initialize) {
                        window.LS160Component.initialize(componentDiv, type);
                    }
                } else if (type === '74280') {
                    // 74LS280奇偶校验器初始化
                    componentStates.set(componentDiv.dataset.id, {
                        A: 0, B: 0, C: 0, D: 0, E: 0, F: 0, G: 0, H: 0, I: 0,
                        FEV: 1, FOD: 0  // 初始状态：0个1，偶校验有效
                    });

                    // 调用74LS280组件的初始化函数
                    if (window.initialize74280Component) {
                        window.initialize74280Component(componentDiv, type);
                    } else if (window.LS280Component && window.LS280Component.initialize) {
                        window.LS280Component.initialize(componentDiv, type);
                    }
                } else if (type === '74139') {
                    // 74139 1路-4路数据分配器初始化
                    componentStates.set(componentDiv.dataset.id, {
                        D: 1, A1: 0, A0: 0,  // D/EN'默认为1（禁用状态）
                        Y0: 1, Y1: 1, Y2: 1, Y3: 1  // 初始输出全为1
                    });

                    // 调用74139组件的初始化函数
                    if (window.initialize74139Component) {
                        window.initialize74139Component(componentDiv, type);
                    }
                } else if (type === 'mod-n-counter') {
                    // 模N计数器初始化
                    componentStates.set(componentDiv.dataset.id, {
                        Q0: 0, Q1: 0, Q2: 0, Q3: 0,
                        RCO: 0, prevCLK: 0, modValue: 5
                    });

                    // 调用模N计数器组件的初始化函数
                    if (window.ModNCounterComponent && window.ModNCounterComponent.initialize) {
                        window.ModNCounterComponent.initialize(componentDiv, type);
                    }
                } else if (type === 'binary-async-counter') {
                    // 二进制异步计数器初始化
                    componentStates.set(componentDiv.dataset.id, {
                        CLK: 0, RST: 1,
                        Q0: 0, Q1: 0, Q2: 0, Q3: 0,
                        OVF: 0,
                        prevCLK: 0, prevQ0: 0, prevQ1: 0, prevQ2: 0,
                        count: 0
                    });

                    // 调用异步计数器组件的初始化函数
                    if (window.BinaryAsyncCounterComponent && window.BinaryAsyncCounterComponent.initialize) {
                        window.BinaryAsyncCounterComponent.initialize(componentDiv, type);
                    }
                } else if (type.startsWith('majority-voter')) {
                    // 多数表决器初始化
                    const inputCount = type === 'majority-voter-5' ? 5 : (type === 'majority-voter-7' ? 7 : 3);
                    const initialState = { Y: 0 };
                    
                    // 根据输入数量初始化输入状态
                    const inputLabels = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
                    for (let i = 0; i < inputCount; i++) {
                        initialState[inputLabels[i]] = 0;
                    }

                    componentStates.set(componentDiv.dataset.id, initialState);

                    // 调用多数表决器组件的初始化函数
                    if (window.MajorityVoterComponent && window.MajorityVoterComponent.initialize) {
                        window.MajorityVoterComponent.initialize(componentDiv, type);
                    }
                } else if (type === '74ls153') {
                    // 74LS153初始化
                    componentStates.set(componentDiv.dataset.id, { Y: 0 });

                    // 调用74LS153组件的初始化函数
                    if (window.LS153Component && window.LS153Component.initialize) {
                        window.LS153Component.initialize(componentDiv, type);
                    }
                } else if (['pin', 'splitter', 'probe', 'power', 'ground'].includes(type)) {
                    // 线路组件初始化
                    window.CircuitComponents.initialize(componentDiv, type);
                    // 设置初始状态
                    if (type === 'power') {
                        componentStates.set(componentDiv.dataset.id, 1);
                    } else {
                        componentStates.set(componentDiv.dataset.id, 0);
                    }
                }

                // 设置组件样式和提示
                if (type === 'output') {
                    componentDiv.style.cursor = 'default';
                    componentDiv.title = '输出端口 - 只能接收信号，不能手动切换';
                } else {
                    componentDiv.style.cursor = 'grab';
                }

                // 添加所有必要的事件监听器
                addComponentEventListeners(componentDiv, type);
            }

            // 添加元件事件监听器的函数
            function addComponentEventListeners(componentDiv, type) {
                // 添加拖动功能
                    let isDragging = false;
                    let offsetX, offsetY;
                    let scale = 1;
                    let transform = '';

                    // 记录元件对应的连线，用于更新
                    const updateWires = () => {
                        const updatedWires = new Set();

                        // 递归更新连线的函数
                        const updateWireRecursively = (wire) => {
                            if (updatedWires.has(wire)) return; // 避免重复更新

                            updatedWires.add(wire);
                            updateWirePosition(wire);

                            // 查找以此连线为分支源的所有分支连线
                            const branchWires = wires.filter(w => w.branchFrom === wire.line);
                            branchWires.forEach(branchWire => {
                                updateWireRecursively(branchWire);
                            });
                        };

                        wires.forEach(wire => {
                            let shouldUpdate = false;

                            // 检查普通连线（两端都是锚点）
                            if (wire.start && wire.start.closest('.component') === componentDiv) {
                                shouldUpdate = true;
                            }
                            if (wire.end && wire.end.closest('.component') === componentDiv) {
                                shouldUpdate = true;
                            }

                            // 检查分支连线（从连线分支到锚点）
                            if (wire.branchFrom && wire.end && wire.end.closest('.component') === componentDiv) {
                                shouldUpdate = true;
                            }

                            // 检查连接到连线的情况（从锚点连接到连线）
                            if (wire.connectsTo && wire.start && wire.start.closest('.component') === componentDiv) {
                                shouldUpdate = true;
                            }

                            // 检查作为目标连线的情况（其他连线连接到这条连线）
                            if (wire.start && wire.end) {
                                const connectingWires = wires.filter(w => w.connectsTo === wire.line);
                                if (connectingWires.length > 0) {
                                    connectingWires.forEach(connectingWire => {
                                        updateWireRecursively(connectingWire);
                                    });
                                }
                            }

                            if (shouldUpdate) {
                                updateWireRecursively(wire);
                            }
                        });
                    };

                    componentDiv.addEventListener('mousedown', function (e) {
                        // 防止拖动锚点时触发元件拖动
                        if (e.target.classList.contains('anchor')) return;

                        // 在连线模式下，不允许拖拽组件
                        if (gestureControl && gestureControl.isConnectMode()) {
                            return;
                        }

                        // 选择元件
                        selectElement(componentDiv);

                        isDragging = true;
                        offsetX = e.clientX - componentDiv.getBoundingClientRect().left;
                        offsetY = e.clientY - componentDiv.getBoundingClientRect().top;
                        if (type !== 'output') {
                            componentDiv.style.cursor = 'grabbing';
                        }
                        componentDiv.style.zIndex = '20'; // 拖动时置于顶层
                    });

                    // 添加右键菜单
                    componentDiv.addEventListener('contextmenu', function (e) {
                        e.preventDefault();
                        selectElement(componentDiv);
                        showContextMenu(e.clientX, e.clientY);
                    });

                    document.addEventListener('mousemove', function (e) {
                        if (!isDragging) return;

                        const canvasRect = canvas.getBoundingClientRect();
                        const componentRect = componentDiv.getBoundingClientRect();

                        let newLeft = e.clientX - offsetX;
                        let newTop = e.clientY - offsetY;

                        // 限制在画布内
                        newLeft = Math.max(canvasRect.left, Math.min(newLeft, canvasRect.right - componentRect.width));
                        newTop = Math.max(canvasRect.top, Math.min(newTop, canvasRect.bottom - componentRect.height));

                        // 应用网格磁吸功能
                        const snapResult = magneticSnap.snapComponentToGrid(componentDiv, newLeft, newTop, canvas);

                        componentDiv.style.left = snapResult.left + 'px';
                        componentDiv.style.top = snapResult.top + 'px';

                        // 更新连线
                        updateWires();
                    });

                    document.addEventListener('mouseup', function () {
                        if (isDragging) {
                            isDragging = false;
                            if (type === 'output') {
                                componentDiv.style.cursor = 'default';
                            } else {
                                componentDiv.style.cursor = 'grab';
                            }
                            componentDiv.style.zIndex = '10'; // 恢复默认层级

                            // 隐藏磁吸指示器
                            magneticSnap.hideAllIndicators();
                        }
                    });

                    // 添加缩放功能
                    componentDiv.addEventListener('wheel', function (e) {
                        e.preventDefault();
                        const delta = e.deltaY > 0 ? 0.9 : 1.1;
                        scale *= delta;
                        scale = Math.max(0.1, Math.min(scale, 5));

                        const svg = componentDiv.querySelector('svg');
                        const rotation = parseInt(componentDiv.dataset.rotation) || 0;
                        svg.style.transform = `rotate(${rotation}deg) scale(${scale})`;
                        componentDiv.dataset.scale = scale;

                        // 更新连线
                        updateWires();
                    });

                    // 为按钮添加特殊的事件处理
                    if (type === 'push-button') {
                        const buttonGroup = componentDiv.querySelector('#push-button-group') || componentDiv;

                        // 按下事件
                        buttonGroup.addEventListener('mousedown', function(e) {
                            if (e.target.classList.contains('anchor')) return;
                            e.preventDefault();

                            const id = componentDiv.dataset.id;
                            const config = typeof getButtonConfig === 'function' ? getButtonConfig(id) : { trigger: 'high' };

                            // 更新视觉状态
                            if (typeof updatePushButtonDisplay === 'function') {
                                updatePushButtonDisplay(componentDiv, 1);
                            }

                            // 根据触发模式处理输出
                            switch(config.trigger) {
                                case 'rising':
                                    // 上升沿：按下瞬间输出1，然后立即回到0
                                    componentStates.set(id, 1);
                                    propagateSignal(componentDiv);
                                    setTimeout(() => {
                                        componentStates.set(id, 0);
                                        propagateSignal(componentDiv);
                                    }, 50);
                                    break;
                                case 'high':
                                    // 高电平：按下时持续输出1
                                    componentStates.set(id, 1);
                                    propagateSignal(componentDiv);
                                    break;
                                case 'low':
                                    // 低电平：按下时输出0
                                    componentStates.set(id, 0);
                                    propagateSignal(componentDiv);
                                    break;
                            }
                        });

                        // 松开事件
                        document.addEventListener('mouseup', function(e) {
                            if (!componentDiv.contains(e.target) && e.target !== componentDiv) return;

                            const id = componentDiv.dataset.id;
                            const config = typeof getButtonConfig === 'function' ? getButtonConfig(id) : { trigger: 'high' };

                            // 更新视觉状态
                            if (typeof updatePushButtonDisplay === 'function') {
                                updatePushButtonDisplay(componentDiv, 0);
                            }

                            // 根据触发模式处理输出
                            switch(config.trigger) {
                                case 'falling':
                                    // 下降沿：释放瞬间输出1，然后立即回到0
                                    componentStates.set(id, 1);
                                    propagateSignal(componentDiv);
                                    setTimeout(() => {
                                        componentStates.set(id, 0);
                                        propagateSignal(componentDiv);
                                    }, 50);
                                    break;
                                case 'high':
                                    // 高电平：释放时回到0
                                    componentStates.set(id, 0);
                                    propagateSignal(componentDiv);
                                    break;
                                case 'low':
                                    // 低电平：释放时回到1
                                    componentStates.set(id, 1);
                                    propagateSignal(componentDiv);
                                    break;
                            }
                        });
                    }

                    // 为开关添加点击切换状态功能
                    if (type === 'switch') {
                        const switchGroup = componentDiv.querySelector('#switch-group') || componentDiv;
                        switchGroup.addEventListener('click', function(e) {
                            // 避免锚点点击触发状态切换
                            if (e.target.classList.contains('anchor')) return;

                            const id = componentDiv.dataset.id;

                            // 获取当前状态并切换
                            const currentState = componentStates.get(id) || 0;
                            const newState = currentState === 0 ? 1 : 0;

                            // 更新状态
                            componentStates.set(id, newState);

                            // 更新视觉状态
                            if (typeof updateSwitchDisplay === 'function') {
                                updateSwitchDisplay(componentDiv, newState);
                            }

                            console.log(`Switch (ID: ${id}) 状态切换为: ${newState}`);
                            console.log(`componentStates.get(${id}):`, componentStates.get(id));

                            // 传播信号
                            propagateSignal(componentDiv);
                        });
                    }

                    // LED二极管组件初始化已在前面处理，这里不再重复调用外部初始化

                    // 为输入/输出端口、时钟信号和引脚添加点击切换状态功能
                    if (type === 'input' || type === 'output' || type === 'clock' || type === 'pin') {
                        const group = componentDiv.querySelector('#input-group') ||
                                     componentDiv.querySelector('#output-group') ||
                                     componentDiv.querySelector('#clock-group') ||
                                     componentDiv.querySelector('#pin-group') ||
                                     componentDiv;
                        group.addEventListener('click', function(e) {
                            // 避免锚点点击触发状态切换
                            if (e.target.classList.contains('anchor')) return;

                            // 输出端口不允许手动点击切换状态，只能接收信号
                            if (type === 'output') {
                                return;
                            }

                            // 引脚在输出模式时不允许手动点击切换状态
                            if (type === 'pin') {
                                const pinMode = componentDiv.dataset.pinMode || 'input';
                                if (pinMode === 'output') {
                                    return;
                                }
                            }

                            const id = componentDiv.dataset.id;
                            
                            if (type === 'input') {
                                // 输入端口的点击处理
                                const bitWidth = getComponentBitWidth(id);
                                if (bitWidth === 1) {
                                    // 单位数据，直接切换
                                    const currentData = getComponentMultiBitData(id);
                                    const newValue = currentData[0] === 0 ? 1 : 0;
                                    setComponentBitData(id, 0, newValue);
                                } else {
                                    // 多位数据，循环切换所有位
                                    const currentValue = componentStates.get(id) || 0;
                                    const maxValue = Math.pow(2, bitWidth) - 1;
                                    const newValue = (currentValue + 1) % (maxValue + 1);
                                    
                                    // 转换为二进制数组
                                    const binaryStr = newValue.toString(2).padStart(bitWidth, '0');
                                    const newData = binaryStr.split('').map(bit => parseInt(bit));
                                    setComponentMultiBitData(id, newData);
                                }
                                updatePortDisplay(id);
                            } else if (type === 'pin') {
                                // 引脚在输入模式时的点击处理
                                const isTriState = componentDiv.dataset.triState === 'true';
                                const currentValue = componentDiv.dataset.pinValue || '0';
                                let newValue;

                                if (isTriState) {
                                    // 三态模式：0 → 1 → X → 0
                                    if (currentValue === '0') {
                                        newValue = '1';
                                    } else if (currentValue === '1') {
                                        newValue = 'x';
                                    } else {
                                        newValue = '0';
                                    }
                                } else {
                                    // 二态模式：0 → 1 → 0
                                    const numValue = parseInt(currentValue);
                                    newValue = (numValue === 0 ? 1 : 0).toString();
                                }

                                componentDiv.dataset.pinValue = newValue;

                                // 更新引脚显示
                                if (window.CircuitComponents && window.CircuitComponents.updatePinDisplay) {
                                    window.CircuitComponents.updatePinDisplay(componentDiv, newValue);
                                }

                                console.log(`引脚 ${id} (输入模式) 值切换为: ${newValue}`);
                            } else {
                                // 时钟信号的原有处理逻辑
                                const currentState = componentStates.get(id);
                                const newState = currentState === 0 ? 1 : 0;
                                componentStates.set(id, newState);

                                // 更新显示
                                if (type === 'clock') {
                                    const bgElement = componentDiv.querySelector('#clock-bg');
                                    if (bgElement) {
                                        bgElement.classList.toggle('clock-active');
                                    }
                                }
                            }

                            console.log(`${type} (ID: ${id}) 状态已切换`);

                            // 触发逻辑计算
                            propagateSignal(componentDiv);
                        });
                    }
                }

            // 点击元件列表项添加元件到画布
            componentItems.forEach(item => {
                item.addEventListener('click', function () {
                    const type = this.getAttribute('data-type');
                    if (!componentSvgs[type]) {
                        console.warn(`组件类型 ${type} 的SVG模板未找到，可能需要等待外部脚本加载`);
                        // 尝试延迟创建，等待外部脚本加载
                        setTimeout(() => {
                            if (componentSvgs[type]) {
                                console.log(`延迟创建组件 ${type}`);
                                createComponentFromSidebar(type);
                            } else {
                                console.error(`组件类型 ${type} 的SVG模板仍未找到，请检查对应的JS文件是否正确加载`);
                            }
                        }, 500);
                        return;
                    }

                    createComponentFromSidebar(type);
                });
            });

            // 从侧边栏创建元件的函数
            function createComponentFromSidebar(type) {
                if (!componentSvgs[type]) {
                    console.warn(`组件 ${type} 的SVG模板未找到，尝试延迟创建...`);

                    // 对于特定组件，尝试延迟创建
                    if (type === '74139') {
                        // 尝试等待74139模块加载
                        let attempts = 0;
                        const maxAttempts = 5;
                        const retryCreate = () => {
                            attempts++;
                            if (componentSvgs[type]) {
                                console.log(`74139组件SVG模板已加载，创建组件（尝试次数: ${attempts}）`);
                                createComponentFromSidebar(type);
                            } else if (attempts < maxAttempts) {
                                setTimeout(retryCreate, 200 * attempts);
                            } else {
                                console.error(`无法创建组件 ${type}：SVG模板在${maxAttempts}次尝试后仍未找到`);
                                alert(`无法创建${type}组件，请刷新页面重试`);
                            }
                        };
                        setTimeout(retryCreate, 100);
                        return;
                    } else {
                        console.error(`无法创建组件 ${type}：SVG模板未找到`);
                        return;
                    }
                }

                // 创建元件容器
                const componentDiv = document.createElement('div');
                componentDiv.className = 'component';
                componentDiv.style.left = '100px';
                componentDiv.style.top = '100px';
                componentDiv.innerHTML = componentSvgs[type];
                componentDiv.dataset.type = type;
                componentDiv.dataset.id = Date.now(); // 唯一ID
                canvas.appendChild(componentDiv);

                // 使用统一的初始化函数
                initializeComponent(componentDiv, type);


            }

            // 锚点和连线拖拽连线功能
            let isDraggingWire = false;
            let dragStartAnchor = null;
            let dragStartWire = null;
            let dragStartPoint = null;
            let tempWire = null;

            // 锚点和连线鼠标按下事件
            canvas.addEventListener('mousedown', function (e) {
                if (e.target.classList.contains('anchor')) {
                    console.log('锚点点击，开始连线');
                    e.preventDefault();
                    e.stopPropagation();

                    isDraggingWire = true;
                    dragStartAnchor = e.target;

                    // 高亮起始锚点（保持正常大小）
                    dragStartAnchor.setAttribute('r', '5');

                    // 获取起始锚点坐标
                    const startRect = dragStartAnchor.getBoundingClientRect();
                    const canvasRect = canvas.getBoundingClientRect();
                    const startX = startRect.left - canvasRect.left + startRect.width / 2;
                    const startY = startRect.top - canvasRect.top + startRect.height / 2;

                    // 设置拖拽起始点
                    dragStartPoint = { x: startX, y: startY };

                    // 创建临时连线（使用path支持转弯）
                    tempWire = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    tempWire.setAttribute('class', 'wire');
                    tempWire.setAttribute('fill', 'none');
                    tempWire.setAttribute('stroke', '#666'); // 灰色临时线
                    tempWire.setAttribute('stroke-dasharray', '5,5'); // 虚线
                    tempWire.setAttribute('stroke-width', '2'); // 正常线宽
                    tempWire.setAttribute('d', `M ${startX} ${startY} L ${startX + 1} ${startY + 1}`);
                    wireLayer.appendChild(tempWire);

                } else if (e.target.classList.contains('wire')) {
                    e.preventDefault();
                    e.stopPropagation();

                    isDraggingWire = true;
                    dragStartWire = e.target;

                    // 获取鼠标在连线上的点击位置
                    const canvasRect = canvas.getBoundingClientRect();
                    const clickX = e.clientX - canvasRect.left;
                    const clickY = e.clientY - canvasRect.top;

                    dragStartPoint = { x: clickX, y: clickY };

                    // 高亮起始连线
                    dragStartWire.setAttribute('stroke', '#0066cc');
                    dragStartWire.setAttribute('stroke-width', '4');

                    // 创建临时连线（使用path支持转弯）
                    tempWire = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    tempWire.setAttribute('class', 'wire');
                    tempWire.setAttribute('fill', 'none');
                    tempWire.setAttribute('stroke', '#666'); // 灰色临时线
                    tempWire.setAttribute('stroke-dasharray', '5,5'); // 虚线
                    tempWire.setAttribute('stroke-width', '2'); // 正常线宽
                    tempWire.setAttribute('d', `M ${clickX} ${clickY} L ${clickX + 1} ${clickY + 1}`);
                    wireLayer.appendChild(tempWire);



                }
            });

            // 鼠标移动事件 - 更新临时连线
            document.addEventListener('mousemove', function (e) {
                // 追踪鼠标下的组件
                hoveredComponent = e.target.closest('.component');

                if (isDraggingWire && tempWire && dragStartPoint) {
                    const canvasRect = canvas.getBoundingClientRect();
                    let mouseX = e.clientX - canvasRect.left;
                    let mouseY = e.clientY - canvasRect.top;

                    // 应用锚点磁吸功能，排除起始锚点
                    const snapResult = magneticSnap.snapToAnchor(e.clientX, e.clientY, canvas,
                        dragStartAnchor ? dragStartAnchor.closest('.component') : null,
                        dragStartAnchor);

                    if (snapResult.snapped) {
                        mouseX = snapResult.relativeX;
                        mouseY = snapResult.relativeY;

                        // 当磁吸到锚点时，使用橙色连线样式表示即将连接
                        tempWire.setAttribute('stroke', '#FF9800');
                        tempWire.setAttribute('stroke-width', '3');
                        tempWire.setAttribute('stroke-dasharray', 'none'); // 移除虚线

                        // 高亮目标锚点
                        if (snapResult.anchor) {
                            snapResult.anchor.setAttribute('r', '6');
                            snapResult.anchor.setAttribute('fill', '#FF9800');
                            snapResult.anchor.setAttribute('stroke', '#FFF');
                            snapResult.anchor.setAttribute('stroke-width', '2');
                        }
                    } else {
                        // 恢复正常连线样式
                        tempWire.setAttribute('stroke', '#666');
                        tempWire.setAttribute('stroke-width', '2');
                        tempWire.setAttribute('stroke-dasharray', '5,5'); // 保持虚线表示未连接

                        // 恢复所有锚点的正常样式（除了起始锚点）
                        const allAnchors = canvas.querySelectorAll('.anchor');
                        allAnchors.forEach(anchor => {
                            if (anchor !== dragStartAnchor) {
                                anchor.setAttribute('r', '4');
                                anchor.setAttribute('fill', 'black');
                                anchor.setAttribute('stroke', 'none');
                                anchor.setAttribute('stroke-width', '0');
                            }
                        });
                    }

                    // 更新临时连线路径，支持转弯
                    const startX = dragStartPoint.x;
                    const startY = dragStartPoint.y;
                    const pathData = calculateBentPath(startX, startY, mouseX, mouseY);
                    tempWire.setAttribute('d', pathData);
                } else if (!isDraggingWire) {
                    // 当不在拖拽连线时，隐藏所有磁吸指示器
                    magneticSnap.hideAllIndicators();
                }
            });

            // 键盘事件 - ESC键取消连线
            document.addEventListener('keydown', function (e) {
                if (e.key === 'Escape' && isDraggingWire) {
                    // 取消连线
                    if (tempWire) {
                        wireLayer.removeChild(tempWire);
                        tempWire = null;
                    }

                    // 恢复起始锚点状态
                    if (dragStartAnchor) {
                        dragStartAnchor.setAttribute('r', '4'); // 恢复到原始大小
                        dragStartAnchor = null;
                    }

                    // 恢复起始连线状态
                    if (dragStartWire) {
                        dragStartWire.setAttribute('stroke', '#000');
                        dragStartWire.setAttribute('stroke-width', '2');
                        dragStartWire = null;
                    }

                    // 恢复所有锚点的正常样式
                    const allAnchors = canvas.querySelectorAll('.anchor');
                    allAnchors.forEach(anchor => {
                        anchor.setAttribute('r', '4');
                        anchor.setAttribute('fill', 'black');
                        anchor.setAttribute('stroke', 'none');
                        anchor.setAttribute('stroke-width', '0');
                    });

                    // 重置状态
                    isDraggingWire = false;
                    dragStartPoint = null;

                    // 隐藏所有磁吸指示器
                    magneticSnap.hideAllIndicators();

                    console.log('连线已取消');
                }
            });

            // 右键点击事件 - 取消连线
            document.addEventListener('contextmenu', function (e) {
                if (isDraggingWire) {
                    e.preventDefault(); // 阻止右键菜单

                    // 取消连线
                    if (tempWire) {
                        wireLayer.removeChild(tempWire);
                        tempWire = null;
                    }

                    // 恢复起始锚点状态
                    if (dragStartAnchor) {
                        dragStartAnchor.setAttribute('r', '4'); // 恢复到原始大小
                        dragStartAnchor = null;
                    }

                    // 恢复起始连线状态
                    if (dragStartWire) {
                        dragStartWire.setAttribute('stroke', '#000');
                        dragStartWire.setAttribute('stroke-width', '2');
                        dragStartWire = null;
                    }

                    // 恢复所有锚点的正常样式
                    const allAnchors = canvas.querySelectorAll('.anchor');
                    allAnchors.forEach(anchor => {
                        anchor.setAttribute('r', '4');
                        anchor.setAttribute('fill', 'black');
                        anchor.setAttribute('stroke', 'none');
                        anchor.setAttribute('stroke-width', '0');
                    });

                    // 重置状态
                    isDraggingWire = false;
                    dragStartPoint = null;

                    // 隐藏所有磁吸指示器
                    magneticSnap.hideAllIndicators();

                    console.log('连线已取消（右键）');
                }
            });

            // 鼠标释放事件 - 完成连线或取消
            document.addEventListener('mouseup', function (e) {
                if (isDraggingWire) {
                    // 使用磁吸功能检测最近的锚点，而不是依赖精确点击
                    const snapResult = magneticSnap.snapToAnchor(e.clientX, e.clientY, canvas,
                        dragStartAnchor ? dragStartAnchor.closest('.component') : null,
                        dragStartAnchor);

                    const targetAnchor = snapResult.snapped ? snapResult.anchor :
                        (e.target.classList.contains('anchor') ? e.target : null);
                    const targetWire = e.target.classList.contains('wire') ? e.target : null;

                    if (targetAnchor) {
                        // 释放在锚点上
                        let canCreateConnection = false;
                        let startX, startY, endX, endY;

                        if (dragStartAnchor) {
                            // 从锚点开始的拖拽
                            if (targetAnchor !== dragStartAnchor) {
                                // 允许所有锚点之间的连接，包括同一元件的锚点
                                canCreateConnection = true;
                                const startRect = dragStartAnchor.getBoundingClientRect();
                                const endRect = targetAnchor.getBoundingClientRect();
                                const canvasRect = canvas.getBoundingClientRect();

                                startX = startRect.left - canvasRect.left + startRect.width / 2;
                                startY = startRect.top - canvasRect.top + startRect.height / 2;
                                endX = endRect.left - canvasRect.left + endRect.width / 2;
                                endY = endRect.top - canvasRect.top + endRect.height / 2;
                            }
                        } else if (dragStartWire && dragStartPoint) {
                            // 从连线开始的拖拽
                            // 允许连接到所有类型的锚点
                            canCreateConnection = true;
                            const endRect = targetAnchor.getBoundingClientRect();
                            const canvasRect = canvas.getBoundingClientRect();

                            startX = dragStartPoint.x;
                            startY = dragStartPoint.y;
                            endX = endRect.left - canvasRect.left + endRect.width / 2;
                            endY = endRect.top - canvasRect.top + endRect.height / 2;
                        }

                        if (canCreateConnection) {
                            // 创建带转弯的连线
                            const wirePath = createBentWire(startX, startY, endX, endY);
                            wireLayer.appendChild(wirePath);

                            // 为连线添加右键菜单
                            wirePath.addEventListener('contextmenu', function (e) {
                                e.preventDefault();
                                selectElement(wirePath);
                                showContextMenu(e.clientX, e.clientY);
                            });

                            // 为连线添加点击选择功能
                            wirePath.addEventListener('click', function (e) {
                                if (!isDraggingWire) {
                                    selectElement(wirePath);
                                }
                            });

                            if (dragStartAnchor) {
                                // 从锚点开始的连线，存储锚点关联
                                wires.push({
                                    line: wirePath,
                                    start: dragStartAnchor,
                                    end: targetAnchor
                                });

                                // 支持多连接：为每个锚点维护一个连接数组
                                if (!anchorConnections.has(dragStartAnchor)) {
                                    anchorConnections.set(dragStartAnchor, []);
                                }
                                if (!anchorConnections.has(targetAnchor)) {
                                    anchorConnections.set(targetAnchor, []);
                                }

                                // 添加双向连接，避免重复
                                const startConnections = anchorConnections.get(dragStartAnchor);
                                const targetConnections = anchorConnections.get(targetAnchor);

                                if (!startConnections.includes(targetAnchor)) {
                                    startConnections.push(targetAnchor);
                                }
                                if (!targetConnections.includes(dragStartAnchor)) {
                                    targetConnections.push(dragStartAnchor);
                                }

                                // 触发逻辑计算
                                propagateSignal(dragStartAnchor.closest('.component') || targetAnchor.closest('.component'));
                            } else if (dragStartWire) {
                                // 从连线开始的连线，创建分支连接
                                const originalWire = wires.find(w => w.line === dragStartWire);
                                let branchRatio = 0.5; // 默认中点

                                // 计算分支点在原连线上的比例
                                if (originalWire && originalWire.start && originalWire.end) {
                                    const startRect = originalWire.start.getBoundingClientRect();
                                    const endRect = originalWire.end.getBoundingClientRect();
                                    const canvasRect = canvas.getBoundingClientRect();

                                    const startX = startRect.left - canvasRect.left + startRect.width / 2;
                                    const startY = startRect.top - canvasRect.top + startRect.height / 2;
                                    const endX = endRect.left - canvasRect.left + endRect.width / 2;
                                    const endY = endRect.top - canvasRect.top + endRect.height / 2;

                                    const totalLength = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                                    const branchLength = Math.sqrt(Math.pow(dragStartPoint.x - startX, 2) + Math.pow(dragStartPoint.y - startY, 2));

                                    branchRatio = totalLength > 0 ? branchLength / totalLength : 0.5;
                                }

                                wires.push({
                                    line: wirePath,
                                    start: null, // 从连线分支，没有起始锚点
                                    end: targetAnchor,
                                    branchFrom: dragStartWire,
                                    branchPoint: dragStartPoint,
                                    branchRatio: branchRatio
                                });

                                // 找到原连线对应的信号源并传播到新的目标锚点
                                if (originalWire && originalWire.start) {
                                    propagateSignal(originalWire.start.closest('.component'));
                                }
                            }
                        }
                    } else if (targetWire && dragStartAnchor) {
                        // 释放在连线上（从锚点拖拽到连线）
                        const canvasRect = canvas.getBoundingClientRect();
                        const releaseX = e.clientX - canvasRect.left;
                        const releaseY = e.clientY - canvasRect.top;

                        // 允许连接到所有连线，包括相关的连线
                        {
                            // 创建从锚点到连线的分支连接
                            const startRect = dragStartAnchor.getBoundingClientRect();
                            const startX = startRect.left - canvasRect.left + startRect.width / 2;
                            const startY = startRect.top - canvasRect.top + startRect.height / 2;

                            // 创建带转弯的连线
                            const line = createBentWire(startX, startY, releaseX, releaseY);
                            wireLayer.appendChild(line);

                            // 为连线添加右键菜单和点击选择功能
                            line.addEventListener('contextmenu', function (e) {
                                e.preventDefault();
                                selectElement(line);
                                showContextMenu(e.clientX, e.clientY);
                            });

                            line.addEventListener('click', function (e) {
                                if (!isDraggingWire) {
                                    selectElement(line);
                                }
                            });

                            // 计算连接点在目标连线上的比例
                            const targetWireData = wires.find(w => w.line === targetWire);
                            let connectionRatio = 0.5; // 默认中点

                            if (targetWireData && targetWireData.start && targetWireData.end) {
                                const targetStartRect = targetWireData.start.getBoundingClientRect();
                                const targetEndRect = targetWireData.end.getBoundingClientRect();

                                const targetStartX = targetStartRect.left - canvasRect.left + targetStartRect.width / 2;
                                const targetStartY = targetStartRect.top - canvasRect.top + targetStartRect.height / 2;
                                const targetEndX = targetEndRect.left - canvasRect.left + targetEndRect.width / 2;
                                const targetEndY = targetEndRect.top - canvasRect.top + targetEndRect.height / 2;

                                const totalLength = Math.sqrt(Math.pow(targetEndX - targetStartX, 2) + Math.pow(targetEndY - targetStartY, 2));
                                const connectionLength = Math.sqrt(Math.pow(releaseX - targetStartX, 2) + Math.pow(releaseY - targetStartY, 2));

                                connectionRatio = totalLength > 0 ? connectionLength / totalLength : 0.5;
                            }

                            // 存储连线信息（反向分支：从锚点到连线）
                            wires.push({
                                line: line,
                                start: dragStartAnchor,
                                end: null, // 连接到连线，没有终点锚点
                                connectsTo: targetWire,
                                connectionPoint: { x: releaseX, y: releaseY },
                                connectionRatio: connectionRatio
                            });

                            console.log("创建了从锚点到连线的连接");

                            // 传播信号
                            propagateSignal(dragStartAnchor.closest('.component'));
                        }
                    }

                    // 清理
                    if (tempWire) {
                        wireLayer.removeChild(tempWire);
                        tempWire = null;
                    }

                    // 恢复起始锚点状态
                    if (dragStartAnchor) {
                        dragStartAnchor.setAttribute('r', '4'); // 恢复到原始大小
                        dragStartAnchor = null;
                    }

                    // 恢复所有锚点的正常样式
                    const allAnchors = canvas.querySelectorAll('.anchor');
                    allAnchors.forEach(anchor => {
                        anchor.setAttribute('r', '4');
                        anchor.setAttribute('fill', 'black');
                        anchor.setAttribute('stroke', 'none');
                        anchor.setAttribute('stroke-width', '0');
                    });

                    // 隐藏所有磁吸指示器
                    magneticSnap.hideAllIndicators();

                    // 恢复起始连线状态
                    if (dragStartWire) {
                        dragStartWire.setAttribute('stroke', '#000');
                        dragStartWire.setAttribute('stroke-width', '2');
                        dragStartWire = null;
                    }

                    dragStartPoint = null;
                    isDraggingWire = false;

                    // 隐藏磁吸指示器
                    magneticSnap.hideAllIndicators();
                }
            });

            // 更新连线位置的函数
            function updateWirePosition(wire) {
                if (wire.branchFrom && wire.branchPoint) {
                    // 分支连线：需要更新分支点位置和终点位置
                    const originalWire = wires.find(w => w.line === wire.branchFrom);
                    if (originalWire) {
                        // 更新分支点位置
                        const updatedBranchPoint = updateBranchPoint(wire, originalWire);

                        // 更新终点位置
                        const endRect = wire.end.getBoundingClientRect();
                        const canvasRect = canvas.getBoundingClientRect();
                        const endX = endRect.left - canvasRect.left + endRect.width / 2;
                        const endY = endRect.top - canvasRect.top + endRect.height / 2;

                        updateWirePath(wire.line, updatedBranchPoint.x, updatedBranchPoint.y, endX, endY);

                        // 更新存储的分支点坐标
                        wire.branchPoint = updatedBranchPoint;
                    }
                } else if (wire.connectsTo && wire.start) {
                    // 从锚点连接到连线的情况
                    const targetWireData = wires.find(w => w.line === wire.connectsTo);
                    if (targetWireData && targetWireData.start && targetWireData.end) {
                        // 更新起点位置（锚点）
                        const startRect = wire.start.getBoundingClientRect();
                        const canvasRect = canvas.getBoundingClientRect();
                        const startX = startRect.left - canvasRect.left + startRect.width / 2;
                        const startY = startRect.top - canvasRect.top + startRect.height / 2;

                        // 根据比例计算目标连线上的连接点
                        const targetStartRect = targetWireData.start.getBoundingClientRect();
                        const targetEndRect = targetWireData.end.getBoundingClientRect();

                        const targetStartX = targetStartRect.left - canvasRect.left + targetStartRect.width / 2;
                        const targetStartY = targetStartRect.top - canvasRect.top + targetStartRect.height / 2;
                        const targetEndX = targetEndRect.left - canvasRect.left + targetEndRect.width / 2;
                        const targetEndY = targetEndRect.top - canvasRect.top + targetEndRect.height / 2;

                        const connectionX = targetStartX + (targetEndX - targetStartX) * wire.connectionRatio;
                        const connectionY = targetStartY + (targetEndY - targetStartY) * wire.connectionRatio;

                        updateWirePath(wire.line, startX, startY, connectionX, connectionY);

                        // 更新存储的连接点坐标
                        wire.connectionPoint = { x: connectionX, y: connectionY };
                    }
                } else if (wire.start && wire.end) {
                    // 普通连线：两端都是锚点
                    const startRect = wire.start.getBoundingClientRect();
                    const endRect = wire.end.getBoundingClientRect();
                    const canvasRect = canvas.getBoundingClientRect();

                    const startX = startRect.left - canvasRect.left + startRect.width / 2;
                    const startY = startRect.top - canvasRect.top + startRect.height / 2;
                    const endX = endRect.left - canvasRect.left + endRect.width / 2;
                    const endY = endRect.top - canvasRect.top + endRect.height / 2;

                    updateWirePath(wire.line, startX, startY, endX, endY);
                }
            }

            // 更新分支点位置的函数
            function updateBranchPoint(branchWire, originalWire) {
                if (!branchWire.branchRatio) {
                    // 如果没有存储分支比例，计算当前比例
                    if (originalWire.start && originalWire.end && branchWire.branchPoint) {
                        const startRect = originalWire.start.getBoundingClientRect();
                        const endRect = originalWire.end.getBoundingClientRect();
                        const canvasRect = canvas.getBoundingClientRect();

                        const startX = startRect.left - canvasRect.left + startRect.width / 2;
                        const startY = startRect.top - canvasRect.top + startRect.height / 2;
                        const endX = endRect.left - canvasRect.left + endRect.width / 2;
                        const endY = endRect.top - canvasRect.top + endRect.height / 2;

                        // 计算分支点在原连线上的比例
                        const totalLength = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                        const branchLength = Math.sqrt(Math.pow(branchWire.branchPoint.x - startX, 2) + Math.pow(branchWire.branchPoint.y - startY, 2));

                        branchWire.branchRatio = totalLength > 0 ? branchLength / totalLength : 0.5;
                    } else {
                        branchWire.branchRatio = 0.5; // 默认中点
                    }
                }

                // 根据当前原连线位置和存储的比例计算新的分支点
                if (originalWire.start && originalWire.end) {
                    const startRect = originalWire.start.getBoundingClientRect();
                    const endRect = originalWire.end.getBoundingClientRect();
                    const canvasRect = canvas.getBoundingClientRect();

                    const startX = startRect.left - canvasRect.left + startRect.width / 2;
                    const startY = startRect.top - canvasRect.top + startRect.height / 2;
                    const endX = endRect.left - canvasRect.left + endRect.width / 2;
                    const endY = endRect.top - canvasRect.top + endRect.height / 2;

                    // 根据比例计算新的分支点位置
                    const newX = startX + (endX - startX) * branchWire.branchRatio;
                    const newY = startY + (endY - startY) * branchWire.branchRatio;

                    return { x: newX, y: newY };
                } else if (originalWire.branchFrom) {
                    // 如果原连线也是分支连线，递归处理
                    const parentWire = wires.find(w => w.line === originalWire.branchFrom);
                    if (parentWire) {
                        const parentBranchPoint = updateBranchPoint(originalWire, parentWire);
                        return parentBranchPoint;
                    }
                }

                // 如果无法计算，返回原分支点
                return branchWire.branchPoint;
            }

            // 信号传播函数
            function propagateSignal(sourceComponent) {
                // 查找所有从sourceComponent出发的连线（包括锚点连接和分支连线）
                const outputAnchors = Array.from(sourceComponent.querySelectorAll('.output-anchor'));

                // 处理锚点连接 - 支持多个连接
                outputAnchors.forEach(anchor => {
                    // 为每个输出锚点获取对应的状态
                    const sourceState = getComponentOutputState(sourceComponent, anchor);

                    if (anchorConnections.has(anchor)) {
                        const targetAnchors = anchorConnections.get(anchor);
                        targetAnchors.forEach(targetAnchor => {
                            propagateToTarget(targetAnchor, sourceState);
                        });
                    }
                });

                // 处理分支连线
                const branchWires = wires.filter(wire => {
                    if (wire.branchFrom) {
                        // 找到分支源连线对应的源组件
                        const originalWire = wires.find(w => w.line === wire.branchFrom);
                        return originalWire && originalWire.start &&
                               originalWire.start.closest('.component') === sourceComponent;
                    }
                    return false;
                });

                branchWires.forEach(wire => {
                    if (wire.end) {
                        // 需要找到对应的输出锚点来获取正确的状态
                        const originalWire = wires.find(w => w.line === wire.branchFrom);
                        if (originalWire && originalWire.start) {
                            const sourceState = getComponentOutputState(sourceComponent, originalWire.start);
                            propagateToTarget(wire.end, sourceState);
                        }
                    }
                });

                // 处理连接到连线的情况（从锚点连接到连线）
                const connectingWires = wires.filter(wire => {
                    return wire.connectsTo && wire.start &&
                           wire.start.closest('.component') === sourceComponent;
                });

                connectingWires.forEach(wire => {
                    // 获取源锚点的状态
                    const sourceState = getComponentOutputState(sourceComponent, wire.start);

                    // 将信号传播到目标连线上的所有连接点
                    const targetWireData = wires.find(w => w.line === wire.connectsTo);
                    if (targetWireData) {
                        // 找到目标连线的终点并传播信号
                        if (targetWireData.end) {
                            propagateToTarget(targetWireData.end, sourceState);
                        }

                        // 找到所有从目标连线分支出去的连线并传播信号
                        const targetBranchWires = wires.filter(w => w.branchFrom === wire.connectsTo);
                        targetBranchWires.forEach(branchWire => {
                            if (branchWire.end) {
                                propagateToTarget(branchWire.end, sourceState);
                            }
                        });
                    }
                });
            }

            // 传播信号到目标锚点
            function propagateToTarget(targetAnchor, sourceState) {
                const targetComponent = targetAnchor.closest('.component');
                const targetType = targetComponent.dataset.type;

                // 根据目标元件类型处理信号
                if (targetType === 'input') {
                    // 输入端口不能接收信号
                    return;
                } else if (targetType === 'output') {
                    // 更新输出端口状态
                    const targetId = targetComponent.dataset.id;
                    const targetBitWidth = getComponentBitWidth(targetId);
                    
                    // 检查源信号是否为多位数据数组
                    if (Array.isArray(sourceState)) {
                        // 源信号是多位数据数组
                        if (targetBitWidth === sourceState.length) {
                            // 位宽匹配，直接复制
                            setComponentMultiBitData(targetId, [...sourceState]);
                        } else if (targetBitWidth > sourceState.length) {
                            // 目标位宽更大，高位补0
                            const paddedData = [...sourceState, ...Array(targetBitWidth - sourceState.length).fill(0)];
                            setComponentMultiBitData(targetId, paddedData);
                        } else {
                            // 目标位宽更小，截取低位
                            const truncatedData = sourceState.slice(0, targetBitWidth);
                            setComponentMultiBitData(targetId, truncatedData);
                        }

                    } else {
                        // 源信号是单一数值
                        if (targetBitWidth === 1) {
                            // 单位输出，直接设置值
                            componentStates.set(targetId, sourceState);
                            const data = [sourceState];
                            setComponentMultiBitData(targetId, data);
                        } else {
                            // 多位输出，将源信号扩展或截断到目标位宽
                            const binaryStr = sourceState.toString(2).padStart(targetBitWidth, '0');
                            const data = binaryStr.split('').map(bit => parseInt(bit));
                            setComponentMultiBitData(targetId, data);
                        }

                    }
                    
                    updatePortDisplay(targetId);
                } else if (isSequentialElement(targetType)) {
                    // RS锁存器是电平触发的，需要立即响应输入信号变化
                    if (targetType === 'rs-latch' && !isClockInput(targetAnchor)) {
                        console.log(`RS锁存器接收到输入信号变化，立即处理`);
                        processRSLatch(targetComponent, 'level'); // 使用'level'表示电平触发
                        return;
                    }

                    // 其他时序逻辑元件不响应普通信号传播，只响应时钟边沿
                    // 但是如果是D输入，我们需要记录当前值供时钟边沿时使用
                    if (targetType === 'd-flipflop' && !isClockInput(targetAnchor)) {
                        // 这里不立即更新输出，只记录输入状态
                    }
                    return;
                } else if (['pin', 'splitter', 'probe', 'power', 'ground'].includes(targetType)) {
                    // 线路组件处理
                    const targetId = targetComponent.dataset.id;

                    if (targetType === 'pin') {
                        // 引脚在输出模式时接收输入信号
                        const pinMode = targetComponent.dataset.pinMode || 'input';
                        if (pinMode === 'output') {
                            // 输出模式的引脚接收输入信号并显示
                            componentStates.set(targetId, sourceState);

                            // 更新引脚显示
                            if (window.CircuitComponents && window.CircuitComponents.updatePinDisplay) {
                                window.CircuitComponents.updatePinDisplay(targetComponent, sourceState);
                            }
                            console.log(`引脚 ${targetId} (输出模式) 接收信号: ${sourceState}`);
                        }
                    } else if (targetType === 'probe') {
                        // 探针显示输入信号
                        componentStates.set(targetId, sourceState);
                        if (window.CircuitComponents && window.CircuitComponents.updateProbeDisplay) {
                            window.CircuitComponents.updateProbeDisplay(targetComponent, sourceState);
                        }
                    } else if (targetType === 'splitter') {
                        // 分线器处理输入信号
                        componentStates.set(targetId, sourceState);
                        // 继续传播信号
                        propagateSignal(targetComponent);
                    } else if (targetType === 'led-diode') {
                        // LED二极管处理输入信号
                        componentStates.set(targetId, sourceState);
                        // 使用内置的LED显示更新函数
                        updateLEDDisplay(targetComponent, sourceState);
                    }
                    // power 和 ground 不接收输入信号
                    return;
                } else {
                    // 组合逻辑门
                    // 收集所有输入锚点的状态
                    const inputAnchors = Array.from(targetComponent.querySelectorAll('.input-anchor'));
                    const inputStates = inputAnchors.map(inputAnchor => {
                        let signalSources = [];

                        // 检查锚点连接 - 支持多个连接
                        if (anchorConnections.has(inputAnchor)) {
                            const sourceAnchors = anchorConnections.get(inputAnchor);
                            console.log(`输入锚点有 ${sourceAnchors.length} 个连接`);
                            sourceAnchors.forEach(sourceAnchor => {
                                const sourceComp = sourceAnchor.closest('.component');
                                const state = getComponentOutputState(sourceComp, sourceAnchor);
                                console.log(`从 ${sourceComp.dataset.type} 获取状态:`, state);
                                // 如果是多位数据数组，转换为十进制数值
                                if (Array.isArray(state)) {
                                    const decimalValue = state.reduce((acc, bit, index) => {
                                        return acc + bit * Math.pow(2, state.length - 1 - index);
                                    }, 0);
                                    signalSources.push(decimalValue > 0 ? 1 : 0); // 逻辑门只关心是否为0
                                } else {
                                    signalSources.push(state);
                                }
                            });
                        } else {
                            console.log('输入锚点没有在 anchorConnections 中找到连接');
                        }

                        // 检查分支连线
                        const branchWire = wires.find(wire => wire.end === inputAnchor && wire.branchFrom);
                        if (branchWire) {
                            const originalWire = wires.find(w => w.line === branchWire.branchFrom);
                            if (originalWire && originalWire.start) {
                                const sourceComp = originalWire.start.closest('.component');
                                const state = getComponentOutputState(sourceComp, originalWire.start);
                                // 处理多位数据
                                if (Array.isArray(state)) {
                                    const decimalValue = state.reduce((acc, bit, index) => {
                                        return acc + bit * Math.pow(2, state.length - 1 - index);
                                    }, 0);
                                    signalSources.push(decimalValue > 0 ? 1 : 0);
                                } else {
                                    signalSources.push(state);
                                }
                            }
                        }

                        // 检查是否有多个连线连接到同一个输入锚点
                        const multipleConnections = wires.filter(wire => wire.end === inputAnchor);
                        multipleConnections.forEach(wire => {
                            if (wire.start && !signalSources.length) { // 避免重复计算
                                const sourceComp = wire.start.closest('.component');
                                const state = getComponentOutputState(sourceComp, wire.start);
                                // 处理多位数据
                                if (Array.isArray(state)) {
                                    const decimalValue = state.reduce((acc, bit, index) => {
                                        return acc + bit * Math.pow(2, state.length - 1 - index);
                                    }, 0);
                                    signalSources.push(decimalValue > 0 ? 1 : 0);
                                } else {
                                    signalSources.push(state);
                                }
                            }
                        });

                        // 检查是否有连线连接到包含此锚点的连线上
                        const parentWires = wires.filter(wire => wire.end === inputAnchor);
                        parentWires.forEach(parentWire => {
                            if (parentWire.line) {
                                // 查找连接到这条连线的其他连线
                                const connectingWires = wires.filter(w => w.connectsTo === parentWire.line);
                                connectingWires.forEach(connectingWire => {
                                    if (connectingWire.start) {
                                        const sourceComp = connectingWire.start.closest('.component');
                                        const state = getComponentOutputState(sourceComp, connectingWire.start);
                                        // 处理多位数据
                                        if (Array.isArray(state)) {
                                            const decimalValue = state.reduce((acc, bit, index) => {
                                                return acc + bit * Math.pow(2, state.length - 1 - index);
                                            }, 0);
                                            signalSources.push(decimalValue > 0 ? 1 : 0);
                                        } else {
                                            signalSources.push(state);
                                        }
                                    }
                                });
                            }
                        });

                        // 如果有多个信号源，进行逻辑OR操作（线或）
                        if (signalSources.length > 1) {
                            console.log(`输入锚点有${signalSources.length}个信号源，进行线或操作`);
                            return signalSources.some(state => state === 1) ? 1 : 0;
                        } else if (signalSources.length === 1) {
                            return signalSources[0];
                        }

                        return 0; // 默认无连接为低电平
                    });

                    // 计算逻辑门输出
                    const outputState = logicFunctions[targetType](inputStates);
                    const targetId = targetComponent.dataset.id;

                    // 处理多输出运算器
                    if (['adder', 'subtractor', 'divider'].includes(targetType)) {
                        // 运算器有多个输出，需要分别存储
                        componentStates.set(targetId, outputState);
                        updateArithmeticComponentDisplay(targetComponent, outputState, targetType);
                    } else if (targetType === 'led-diode') {
                        // LED二极管组件逻辑：直接传递输入状态
                        componentStates.set(targetId, outputState);
                        // 立即更新LED显示
                        updateLEDDisplay(targetComponent, outputState);
                    } else if (['jk-flipflop', 't-flipflop', 'tp-flipflop', 'counter', 'rs-latch'].includes(targetType)) {
                        // 时序逻辑组件处理
                        componentStates.set(targetId, outputState);

                        // 调用对应组件的逻辑处理函数
                        if (targetType === 'jk-flipflop' && window.JKFlipFlopComponent && window.JKFlipFlopComponent.logic) {
                            window.JKFlipFlopComponent.logic(inputStates, targetComponent);
                        } else if (targetType === 't-flipflop' && window.TFlipFlopComponent && window.TFlipFlopComponent.logic) {
                            window.TFlipFlopComponent.logic(inputStates, targetComponent);
                        } else if (targetType === 'tp-flipflop' && window.TPFlipFlopComponent && window.TPFlipFlopComponent.logic) {
                            window.TPFlipFlopComponent.logic(inputStates, targetComponent);
                        } else if (targetType === 'counter' && window.CounterComponent && window.CounterComponent.logic) {
                            window.CounterComponent.logic(inputStates, targetComponent);
                        } else if (targetType === 'rs-latch' && window.RSLatchComponent && window.RSLatchComponent.logic) {
                            window.RSLatchComponent.logic(inputStates, targetComponent);
                        }

                        updateComponentDisplay(targetComponent, outputState);
                        console.log(`时序逻辑组件 ${targetType} ${targetId} 处理信号: ${outputState}`);
                    } else if (targetType === '74ls138') {
                        // 74LS138译码器处理
                        const inputs = get74LS138InputStates(targetComponent);
                        const outputState = logicFunctions['74ls138'](inputs);
                        componentStates.set(targetId, outputState);

                        console.log(`74LS138 ${targetId} 输入:`, inputs, '输出:', outputState);

                        // 继续传播信号
                        propagateSignal(targetComponent);
                    } else if (targetType === '74ls151') {
                        // 74LS151数据选择器处理
                        const inputs = get74LS151InputStates(targetComponent);
                        const outputState = logicFunctions['74ls151'](inputs);
                        componentStates.set(targetId, outputState);

                        console.log(`74LS151 ${targetId} 输入:`, inputs, '输出:', outputState);

                        // 继续传播信号
                        propagateSignal(targetComponent);
                    } else if (targetType === '74ls161') {
                        // 74LS161同步计数器处理
                        const inputs = get74LS161InputStates(targetComponent);
                        const currentState = componentStates.get(targetId) || {};
                        const outputState = logicFunctions['74ls161'](inputs, currentState);
                        componentStates.set(targetId, outputState);

                        console.log(`74LS161 ${targetId} 输入:`, inputs, '输出:', outputState);

                        // 继续传播信号
                        propagateSignal(targetComponent);
                    } else if (targetType === '74ls175') {
                        // 74LS175四位并行寄存器处理
                        const inputs = get74LS175InputStates(targetComponent);
                        const currentState = componentStates.get(targetId) || {};
                        const outputState = logicFunctions['74ls175'](inputs, currentState);
                        componentStates.set(targetId, outputState);

                        console.log(`74LS175 ${targetId} 输入:`, inputs, '输出:', outputState);

                        // 继续传播信号
                        propagateSignal(targetComponent);
                    } else if (targetType === '74ls160') {
                        // 74LS160同步十进制计数器处理
                        const inputs = get74LS160InputStates(targetComponent);
                        const currentState = componentStates.get(targetId) || {};
                        const outputState = logicFunctions['74ls160'](inputs, currentState);
                        componentStates.set(targetId, outputState);

                        console.log(`74LS160 ${targetId} 输入:`, inputs, '输出:', outputState);

                        // 继续传播信号
                        propagateSignal(targetComponent);
                    } else if (targetType === 'mod-n-counter') {
                        // 模N计数器处理
                        const inputs = getModNCounterInputStates(targetComponent);
                        const currentState = componentStates.get(targetId) || {
                            Q0: 0, Q1: 0, Q2: 0, Q3: 0,
                            RCO: 0, prevCLK: 0, modValue: 5
                        };
                        const outputState = logicFunctions['mod-n-counter'](inputs, currentState);
                        componentStates.set(targetId, outputState);

                        console.log(`模N计数器 ${targetId} 输入:`, inputs, '输出:', outputState);

                        // 继续传播信号
                        propagateSignal(targetComponent);
                    } else if (targetType === 'binary-async-counter') {
                        // 二进制异步计数器处理
                        const inputs = getBinaryAsyncCounterInputStates(targetComponent);
                        const currentState = componentStates.get(targetId) || {
                            CLK: 0, RST: 1,
                            Q0: 0, Q1: 0, Q2: 0, Q3: 0,
                            OVF: 0,
                            prevCLK: 0, prevQ0: 0, prevQ1: 0, prevQ2: 0,
                            count: 0
                        };
                        const outputState = logicFunctions['binary-async-counter'](inputs, currentState);
                        componentStates.set(targetId, outputState);

                        // 更新显示
                        if (window.BinaryAsyncCounterComponent && window.BinaryAsyncCounterComponent.updateDisplay) {
                            window.BinaryAsyncCounterComponent.updateDisplay(targetComponent);
                        }

                        console.log(`异步计数器 ${targetId} 输入:`, inputs, '输出:', outputState);

                        // 继续传播信号
                        propagateSignal(targetComponent);
                    } else if (targetType.startsWith('majority-voter')) {
                        // 多数表决器处理
                        const inputs = getMajorityVoterInputStates(targetComponent);
                        const outputState = logicFunctions[targetType](inputs);
                        componentStates.set(targetId, outputState);

                        // 更新显示
                        if (window.MajorityVoterComponent && window.MajorityVoterComponent.updateDisplay) {
                            window.MajorityVoterComponent.updateDisplay(targetComponent, targetType);
                        }

                        console.log(`多数表决器 ${targetId} 输入:`, inputs, '输出:', outputState);

                        // 继续传播信号
                        propagateSignal(targetComponent);
                    } else if (targetType === '74ls153') {
                        // 74LS153处理
                        const inputs = get74LS153InputStates(targetComponent);
                        const outputState = logicFunctions['74ls153'](inputs);
                        componentStates.set(targetId, outputState);

                        console.log(`74LS153 ${targetId} 输入:`, inputs, '输出:', outputState);

                        // 更新显示 - 确保在状态设置后立即更新
                        if (window.updateLS153Display) {
                            window.updateLS153Display(targetComponent);
                        } else {
                            console.warn('updateLS153Display函数未找到');
                        }

                        // 继续传播信号
                        propagateSignal(targetComponent);
                    } else if (targetType === '74280') {
                        // 74LS280奇偶校验器处理
                        const inputs = get74280InputStates(targetComponent);
                        const outputState = logicFunctions['74280'](inputs);
                        componentStates.set(targetId, outputState);

                        console.log(`74LS280 ${targetId} 输入:`, inputs, '输出:', outputState);

                        // 继续传播信号
                        propagateSignal(targetComponent);
                    } else if (targetType === '74139') {
                        // 74139数据分配器处理
                        const inputs = get74139InputStates(targetComponent);
                        const outputState = logicFunctions['74139'](inputs);
                        componentStates.set(targetId, outputState);

                        console.log(`74139 ${targetId} 输入:`, inputs, '输出:', outputState);
                        console.log(`74139 ${targetId} 地址计算: (${inputs.A1} << 1) | ${inputs.A0} = ${(inputs.A1 << 1) | inputs.A0}`);

                        // 更新显示
                        updateComponentDisplay(targetComponent, outputState);

                        // 继续传播信号
                        propagateSignal(targetComponent);
                    } else {
                        // 普通逻辑门只有一个输出
                        componentStates.set(targetId, outputState);
                        updateComponentDisplay(targetComponent, outputState);
                    }

                    // 继续传播信号
                    if (!['74ls138', '74ls151', '74ls161', '74ls175', '74ls160', '74280', '74139', 'mod-n-counter'].includes(targetType)) {
                        propagateSignal(targetComponent);
                    }
                }
            }
            
            // 获取元件输出状态
            function getComponentOutputState(component, outputAnchor = null) {
                if (!component || !component.dataset) {
                    console.error('getComponentOutputState: component is null or has no dataset');
                    return 0;
                }

                const id = component.dataset.id;
                const type = component.dataset.type;

                if (type === 'input') {
                    // 输入端口返回多位数据数组
                    const multiData = getComponentMultiBitData(id);
                    const singleValue = Array.isArray(multiData) ? multiData[0] : multiData;
                    console.log(`getComponentOutputState for input (ID: ${id}):`, 'multiData=', multiData, 'singleValue=', singleValue);
                    return singleValue;
                } else if (type === 'output' || type === 'clock' || type === 'push-button' || type === 'switch' || type === 'led-diode') {
                    const state = componentStates.get(id);
                    return state;
                } else if (['d-flipflop', 'jk-flipflop', 't-flipflop', 'tp-flipflop', 'counter', 'rs-latch'].includes(type)) {
                    // 时序逻辑组件有多个输出，需要根据输出锚点确定返回哪个值
                    const sequentialState = sequentialElements.get(id);
                    if (!sequentialState || !outputAnchor) return 0;

                    // 根据锚点位置确定输出类型
                    const anchorY = parseInt(outputAnchor.getAttribute('cy'));
                    if (['d-flipflop', 'jk-flipflop', 't-flipflop', 'tp-flipflop'].includes(type)) {
                        // 触发器：上面的锚点是Q输出，下面的是Q̄输出
                        return anchorY <= 55 ? sequentialState.q : sequentialState.qBar;
                    } else if (type === 'counter') {
                        // 计数器：根据锚点位置返回不同的输出
                        const outputAnchors = Array.from(component.querySelectorAll('.output-anchor'));
                        const anchorIndex = outputAnchors.indexOf(outputAnchor);

                        if (outputAnchors.length === 1) {
                            // 只有一个输出，返回计数值
                            return sequentialState.count || 0;
                        } else if (outputAnchors.length === 2) {
                            // 两个输出：上面是计数值，下面是carry
                            if (anchorIndex === 0 || anchorY <= 55) {
                                return sequentialState.count || 0;
                            } else {
                                return sequentialState.carry || 0;
                            }
                        } else {
                            // 多个输出，默认返回计数值
                            return sequentialState.count || 0;
                        }
                    } else if (type === 'rs-latch') {
                        // RS锁存器：上面的锚点是Q输出，下面的是Q̄输出
                        return anchorY <= 55 ? sequentialState.q : sequentialState.qBar;
                    }
                    return 0;
                } else if (['adder', 'subtractor', 'divider'].includes(type)) {
                    // 运算器有多个输出，需要根据输出锚点确定返回哪个值
                    const state = componentStates.get(id);
                    if (!state || !outputAnchor) return 0;

                    // 根据锚点位置确定输出类型
                    const anchorY = parseInt(outputAnchor.getAttribute('cy'));
                    if (type === 'adder') {
                        return anchorY === 50 ? state.sum : state.carry;
                    } else if (type === 'subtractor') {
                        return anchorY === 50 ? state.difference : state.borrow;
                    } else if (type === 'divider') {
                        return anchorY === 50 ? state.quotient : state.remainder;
                    }
                    return 0;
                } else if (['pin', 'splitter', 'probe', 'power', 'ground'].includes(type)) {
                    // 线路组件使用专门的逻辑函数
                    if (window.CircuitComponents && window.CircuitComponents.logicFunctions) {
                        const logicFunction = window.CircuitComponents.logicFunctions[type];
                        if (logicFunction) {
                            // 获取输入状态
                            const inputs = getComponentInputStates(component);
                            console.log(`调用${type}逻辑函数，输入:`, inputs, '输入详情:', inputs.map((i, idx) => `[${idx}]: ${typeof i}${Array.isArray(i) ? '(array)' : ''} = ${Array.isArray(i) ? '[' + i.join(',') + ']' : i}`));
                            // 对于分线器，传递输出锚点参数以确定返回哪个输出
                            if (type === 'splitter') {
                                return logicFunction(inputs, component, outputAnchor);
                            } else {
                                return logicFunction(inputs, component);
                            }
                        }
                    }
                    return componentStates.get(id) || 0;
                } else if (type === '74ls138') {
                    // 74LS138译码器有8个输出，需要根据输出锚点确定返回哪个值
                    const state = componentStates.get(id);
                    if (!state || !outputAnchor) return 1; // 默认返回1（高电平）

                    // 根据锚点的data-pin属性确定输出
                    const pinName = outputAnchor.getAttribute('data-pin');
                    if (pinName && state[pinName] !== undefined) {
                        return state[pinName];
                    }

                    // 如果没有data-pin属性，根据锚点位置确定输出
                    const anchorY = parseInt(outputAnchor.getAttribute('cy'));
                    const outputMapping = {
                        '-80': 'Y0', '-60': 'Y1', '-40': 'Y2', '-20': 'Y3',
                        '0': 'Y4', '20': 'Y5', '40': 'Y6', '60': 'Y7'
                    };
                    const outputPin = outputMapping[anchorY.toString()];
                    return outputPin ? (state[outputPin] || 1) : 1;
                } else if (type === '74ls151') {
                    // 74LS151数据选择器有2个输出，需要根据输出锚点确定返回哪个值
                    const state = componentStates.get(id);
                    if (!state || !outputAnchor) return 0; // 默认返回0（低电平）

                    // 根据锚点的data-pin属性确定输出
                    const pinName = outputAnchor.getAttribute('data-pin');
                    if (pinName && state[pinName] !== undefined) {
                        return state[pinName];
                    }

                    // 如果没有data-pin属性，根据锚点位置确定输出
                    const anchorY = parseInt(outputAnchor.getAttribute('cy'));
                    const outputMapping = {
                        '-40': 'Y',   // Y输出
                        '-20': 'W'    // W̅输出
                    };
                    const outputPin = outputMapping[anchorY.toString()];
                    return outputPin ? (state[outputPin] || 0) : 0;
                } else if (type === '74ls161') {
                    // 74LS161同步计数器有5个输出，需要根据输出锚点确定返回哪个值
                    const state = componentStates.get(id);
                    if (!state || !outputAnchor) return 0; // 默认返回0（低电平）

                    // 根据锚点的data-pin属性确定输出
                    const pinName = outputAnchor.getAttribute('data-pin');
                    if (pinName && state[pinName] !== undefined) {
                        return state[pinName];
                    }

                    // 如果没有data-pin属性，根据锚点位置确定输出
                    const anchorY = parseInt(outputAnchor.getAttribute('cy'));
                    const outputMapping = {
                        '-40': 'Q0',   // Q0输出
                        '-20': 'Q1',   // Q1输出
                        '0': 'Q2',     // Q2输出
                        '20': 'Q3',    // Q3输出
                        '60': 'RCO'    // RCO进位输出
                    };
                    const outputPin = outputMapping[anchorY.toString()];
                    return outputPin ? (state[outputPin] || 0) : 0;
                } else if (type === '74ls175') {
                    // 74LS175四位并行寄存器有8个输出，需要根据输出锚点确定返回哪个值
                    const state = componentStates.get(id);
                    if (!state || !outputAnchor) return 0; // 默认返回0（低电平）

                    // 根据锚点的data-pin属性确定输出
                    const pinName = outputAnchor.getAttribute('data-pin');
                    if (pinName && state[pinName] !== undefined) {
                        return state[pinName];
                    }

                    // 如果没有data-pin属性，根据锚点位置确定输出
                    const anchorY = parseInt(outputAnchor.getAttribute('cy'));
                    const outputMapping = {
                        '-40': 'Q1',   // Q1输出
                        '-20': 'Q2',   // Q2输出
                        '0': 'Q3',     // Q3输出
                        '20': 'Q4',    // Q4输出
                        '60': 'NQ1',   // \Q1输出
                        '80': 'NQ2',   // \Q2输出
                        '100': 'NQ3',  // \Q3输出
                        '120': 'NQ4'   // \Q4输出
                    };
                    const outputPin = outputMapping[anchorY.toString()];
                    return outputPin ? (state[outputPin] || 0) : 0;
                } else if (type === '74ls160') {
                    // 74LS160同步十进制计数器有5个输出，需要根据输出锚点确定返回哪个值
                    const state = componentStates.get(id);
                    if (!state || !outputAnchor) return 0; // 默认返回0（低电平）

                    // 根据锚点的data-pin属性确定输出
                    const pinName = outputAnchor.getAttribute('data-pin');
                    if (pinName && state[pinName] !== undefined) {
                        return state[pinName];
                    }

                    // 如果没有data-pin属性，根据锚点位置确定输出
                    const anchorY = parseInt(outputAnchor.getAttribute('cy'));
                    const outputMapping = {
                        '-40': 'Q0',   // Q0输出
                        '-20': 'Q1',   // Q1输出
                        '0': 'Q2',     // Q2输出
                        '20': 'Q3',    // Q3输出
                        '60': 'RCO'    // RCO进位输出
                    };
                    const outputPin = outputMapping[anchorY.toString()];
                    return outputPin ? (state[outputPin] || 0) : 0;
                } else if (type === '74280') {
                    // 74LS280奇偶校验器有2个输出，需要根据输出锚点确定返回哪个值
                    const state = componentStates.get(id);
                    if (!state || !outputAnchor) return 0; // 默认返回0（低电平）

                    // 根据锚点的data-pin属性确定输出
                    const pinName = outputAnchor.getAttribute('data-pin');
                    if (pinName && state[pinName] !== undefined) {
                        return state[pinName];
                    }

                    // 如果没有data-pin属性，根据锚点位置确定输出
                    const anchorY = parseInt(outputAnchor.getAttribute('cy'));
                    const outputMapping = {
                        '-40': 'FEV',  // 偶校验输出
                        '40': 'FOD'    // 奇校验输出
                    };
                    const outputPin = outputMapping[anchorY.toString()];
                    return outputPin ? (state[outputPin] || 0) : 0;
                } else if (type === '74139') {
                    // 74139数据分配器有4个输出，需要根据输出锚点确定返回哪个值
                    const state = componentStates.get(id);
                    if (!state || !outputAnchor) return 0; // 默认返回0（低电平）

                    // 根据锚点的data-pin属性确定输出
                    const pinName = outputAnchor.getAttribute('data-pin');
                    if (pinName && state[pinName] !== undefined) {
                        return state[pinName];
                    }

                    // 如果没有data-pin属性，根据锚点位置确定输出
                    const anchorY = parseInt(outputAnchor.getAttribute('cy'));
                    const outputMapping = {
                        '-40': 'Y0',  // Y0输出
                        '-20': 'Y1',  // Y1输出
                        '0': 'Y2',    // Y2输出
                        '20': 'Y3'    // Y3输出
                    };
                    const outputPin = outputMapping[anchorY.toString()];
                    return outputPin ? (state[outputPin] || 0) : 0;
                } else if (type === '74ls153') {
                    // 74LS153数据选择器只有一个输出Y
                    const state = componentStates.get(id);
                    if (!state) return 0; // 默认返回0（低电平）

                    console.log(`getComponentOutputState for 74LS153 (ID: ${id}):`, state);
                    return state.Y || 0;
                } else if (type === 'mod-n-counter') {
                    // 模N计数器有5个输出，需要根据输出锚点确定返回哪个值
                    const state = componentStates.get(id);
                    if (!state || !outputAnchor) return 0; // 默认返回0（低电平）

                    // 根据锚点的data-pin属性确定输出
                    const pinName = outputAnchor.getAttribute('data-pin');
                    if (pinName && state[pinName] !== undefined) {
                        return state[pinName];
                    }

                    // 如果没有data-pin属性，根据锚点位置确定输出
                    const anchorY = parseInt(outputAnchor.getAttribute('cy'));
                    const outputMapping = {
                        '-40': 'Q3',   // Q3输出
                        '-20': 'Q2',   // Q2输出
                        '0': 'Q1',     // Q1输出
                        '20': 'Q0',    // Q0输出
                        '40': 'RCO'    // RCO进位输出
                    };
                    const outputPin = outputMapping[anchorY.toString()];
                    return outputPin ? (state[outputPin] || 0) : 0;
                } else {
                    // 普通逻辑门和求补器
                    return componentStates.get(id) || 0;
                }
            }

            // 获取组件的输入状态数组
            function getComponentInputStates(component) {
                const inputAnchors = Array.from(component.querySelectorAll('.input-anchor'));
                const componentType = component.dataset.type;

                return inputAnchors.map((inputAnchor, anchorIndex) => {
                    const signalSources = [];

                    // 检查直接连接的锚点
                    if (anchorConnections.has(inputAnchor)) {
                        const sourceAnchors = anchorConnections.get(inputAnchor);
                        sourceAnchors.forEach(sourceAnchor => {
                            const sourceComp = sourceAnchor.closest('.component');
                            if (sourceComp) {
                                const state = getComponentOutputState(sourceComp, sourceAnchor);
                                const targetComponent = inputAnchor.closest('.component');
                                console.log(`    锚点连接: 源组件${sourceComp.dataset.type} -> 目标组件${targetComponent?.dataset.type}, 状态:`, state, '类型:', typeof state);

                                // 处理多位数据
                                if (Array.isArray(state)) {
                                    // 对于分线器，保持原始数组
                                    if (targetComponent && targetComponent.dataset.type === 'splitter') {
                                        console.log(`      分线器接收原始数组:`, state);
                                        signalSources.push(state); // 分线器接收原始数组
                                    } else {
                                        // 其他组件转换为十进制值
                                        const decimalValue = state.reduce((acc, bit, index) => {
                                            return acc + bit * Math.pow(2, state.length - 1 - index);
                                        }, 0);
                                        console.log(`      转换数组为十进制: ${state} -> ${decimalValue}`);
                                        signalSources.push(decimalValue);
                                    }
                                } else {
                                    console.log(`      直接使用数值:`, state);
                                    signalSources.push(state);
                                }
                            }
                        });
                    }

                    // 检查连线连接
                    const connectingWires = wires.filter(wire => wire.end === inputAnchor);
                    connectingWires.forEach(wire => {
                        if (wire.start) {
                            const sourceComp = wire.start.closest('.component');
                            if (sourceComp) {
                                const state = getComponentOutputState(sourceComp, wire.start);
                                // 处理多位数据
                                if (Array.isArray(state)) {
                                    // 对于分线器，保持原始数组
                                    const targetComponent = inputAnchor.closest('.component');
                                    if (targetComponent && targetComponent.dataset.type === 'splitter') {
                                        signalSources.push(state); // 分线器接收原始数组
                                    } else {
                                        // 其他组件转换为十进制值
                                        const decimalValue = state.reduce((acc, bit, index) => {
                                            return acc + bit * Math.pow(2, state.length - 1 - index);
                                        }, 0);
                                        signalSources.push(decimalValue);
                                    }
                                } else {
                                    signalSources.push(state);
                                }
                            }
                        }
                    });

                    // 如果有多个信号源，进行逻辑OR操作（线或）
                    if (signalSources.length > 1) {
                        // 检查是否有数组类型的信号源
                        const arraySource = signalSources.find(source => Array.isArray(source));
                        if (arraySource) {
                            // 如果有数组信号源，优先返回数组（多位数据优先）
                            return arraySource;
                        } else {
                            // 否则进行逻辑OR操作
                            return signalSources.some(state => state === 1) ? 1 : 0;
                        }
                    } else if (signalSources.length === 1) {
                        const result = signalSources[0];
                        console.log(`  锚点${anchorIndex}: 返回结果:`, result, '类型:', typeof result, '是否为数组:', Array.isArray(result));
                        return result;
                    }

                    console.log(`  锚点${anchorIndex}: 无信号源，返回默认值0`);
                    return 0; // 默认无连接为低电平
                });
            }

            // 获取74LS138组件的命名输入状态
            function get74LS138InputStates(component) {
                const inputAnchors = Array.from(component.querySelectorAll('.input-anchor'));
                const inputs = {};

                inputAnchors.forEach(inputAnchor => {
                    const pinName = inputAnchor.getAttribute('data-pin');
                    if (!pinName) return;

                    const signalSources = [];

                    // 检查直接连接的锚点
                    if (anchorConnections.has(inputAnchor)) {
                        const sourceAnchors = anchorConnections.get(inputAnchor);
                        sourceAnchors.forEach(sourceAnchor => {
                            const sourceComp = sourceAnchor.closest('.component');
                            if (sourceComp) {
                                const state = getComponentOutputState(sourceComp, sourceAnchor);
                                // 处理多位数据，转换为十进制值
                                if (Array.isArray(state)) {
                                    const decimalValue = state.reduce((acc, bit, index) => {
                                        return acc + bit * Math.pow(2, state.length - 1 - index);
                                    }, 0);
                                    signalSources.push(decimalValue);
                                } else {
                                    signalSources.push(state);
                                }
                            }
                        });
                    }

                    // 检查连线连接
                    const connectingWires = wires.filter(wire => wire.end === inputAnchor);
                    connectingWires.forEach(wire => {
                        if (wire.start) {
                            const sourceComp = wire.start.closest('.component');
                            if (sourceComp) {
                                const state = getComponentOutputState(sourceComp, wire.start);
                                if (Array.isArray(state)) {
                                    const decimalValue = state.reduce((acc, bit, index) => {
                                        return acc + bit * Math.pow(2, state.length - 1 - index);
                                    }, 0);
                                    signalSources.push(decimalValue);
                                } else {
                                    signalSources.push(state);
                                }
                            }
                        }
                    });

                    // 设置输入值
                    if (signalSources.length > 1) {
                        inputs[pinName] = signalSources.some(state => state === 1) ? 1 : 0;
                    } else if (signalSources.length === 1) {
                        inputs[pinName] = signalSources[0];
                    } else {
                        inputs[pinName] = 0; // 默认无连接为低电平
                    }
                });

                return inputs;
            }

            // 获取74LS151组件的命名输入状态
            function get74LS151InputStates(component) {
                const inputAnchors = Array.from(component.querySelectorAll('.input-anchor'));
                const inputs = {};

                inputAnchors.forEach(inputAnchor => {
                    const pinName = inputAnchor.getAttribute('data-pin');
                    if (!pinName) return;

                    const signalSources = [];

                    // 检查直接连接的锚点
                    if (anchorConnections.has(inputAnchor)) {
                        const sourceAnchors = anchorConnections.get(inputAnchor);
                        sourceAnchors.forEach(sourceAnchor => {
                            const sourceComp = sourceAnchor.closest('.component');
                            if (sourceComp) {
                                const state = getComponentOutputState(sourceComp, sourceAnchor);
                                // 处理多位数据，转换为十进制值
                                if (Array.isArray(state)) {
                                    const decimalValue = state.reduce((acc, bit, index) => {
                                        return acc + bit * Math.pow(2, state.length - 1 - index);
                                    }, 0);
                                    signalSources.push(decimalValue);
                                } else {
                                    signalSources.push(state);
                                }
                            }
                        });
                    }

                    // 检查连线连接
                    const connectingWires = wires.filter(wire => wire.end === inputAnchor);
                    connectingWires.forEach(wire => {
                        if (wire.start) {
                            const sourceComp = wire.start.closest('.component');
                            if (sourceComp) {
                                const state = getComponentOutputState(sourceComp, wire.start);
                                if (Array.isArray(state)) {
                                    const decimalValue = state.reduce((acc, bit, index) => {
                                        return acc + bit * Math.pow(2, state.length - 1 - index);
                                    }, 0);
                                    signalSources.push(decimalValue);
                                } else {
                                    signalSources.push(state);
                                }
                            }
                        }
                    });

                    // 设置输入值
                    if (signalSources.length > 1) {
                        inputs[pinName] = signalSources.some(state => state === 1) ? 1 : 0;
                    } else if (signalSources.length === 1) {
                        inputs[pinName] = signalSources[0];
                    } else {
                        inputs[pinName] = 0; // 默认无连接为低电平
                    }
                });

                return inputs;
            }

            // 获取74LS161组件的命名输入状态
            function get74LS161InputStates(component) {
                const inputAnchors = Array.from(component.querySelectorAll('.input-anchor'));
                const inputs = {};

                inputAnchors.forEach(inputAnchor => {
                    const pinName = inputAnchor.getAttribute('data-pin');
                    if (!pinName) return;

                    const signalSources = [];

                    // 检查直接连接的锚点
                    if (anchorConnections.has(inputAnchor)) {
                        const sourceAnchors = anchorConnections.get(inputAnchor);
                        sourceAnchors.forEach(sourceAnchor => {
                            const sourceComp = sourceAnchor.closest('.component');
                            if (sourceComp) {
                                const state = getComponentOutputState(sourceComp, sourceAnchor);
                                // 处理多位数据，转换为十进制值
                                if (Array.isArray(state)) {
                                    const decimalValue = state.reduce((acc, bit, index) => {
                                        return acc + bit * Math.pow(2, state.length - 1 - index);
                                    }, 0);
                                    signalSources.push(decimalValue);
                                } else {
                                    signalSources.push(state);
                                }
                            }
                        });
                    }

                    // 检查连线连接
                    const connectingWires = wires.filter(wire => wire.end === inputAnchor);
                    connectingWires.forEach(wire => {
                        if (wire.start) {
                            const sourceComp = wire.start.closest('.component');
                            if (sourceComp) {
                                const state = getComponentOutputState(sourceComp, wire.start);
                                if (Array.isArray(state)) {
                                    const decimalValue = state.reduce((acc, bit, index) => {
                                        return acc + bit * Math.pow(2, state.length - 1 - index);
                                    }, 0);
                                    signalSources.push(decimalValue);
                                } else {
                                    signalSources.push(state);
                                }
                            }
                        }
                    });

                    // 设置输入值
                    if (signalSources.length > 1) {
                        inputs[pinName] = signalSources.some(state => state === 1) ? 1 : 0;
                    } else if (signalSources.length === 1) {
                        inputs[pinName] = signalSources[0];
                    } else {
                        inputs[pinName] = 0; // 默认无连接为低电平
                    }
                });

                return inputs;
            }

            // 获取74LS175组件的命名输入状态
            function get74LS175InputStates(component) {
                const inputAnchors = Array.from(component.querySelectorAll('.input-anchor'));
                const inputs = {};

                inputAnchors.forEach(inputAnchor => {
                    const pinName = inputAnchor.getAttribute('data-pin');
                    if (!pinName) return;

                    const signalSources = [];

                    // 检查直接连接的锚点
                    if (anchorConnections.has(inputAnchor)) {
                        const sourceAnchors = anchorConnections.get(inputAnchor);
                        sourceAnchors.forEach(sourceAnchor => {
                            const sourceComp = sourceAnchor.closest('.component');
                            if (sourceComp) {
                                const state = getComponentOutputState(sourceComp, sourceAnchor);
                                // 处理多位数据，转换为十进制值
                                if (Array.isArray(state)) {
                                    const decimalValue = state.reduce((acc, bit, index) => {
                                        return acc + bit * Math.pow(2, state.length - 1 - index);
                                    }, 0);
                                    signalSources.push(decimalValue);
                                } else {
                                    signalSources.push(state);
                                }
                            }
                        });
                    }

                    // 检查连线连接
                    const connectingWires = wires.filter(wire => wire.end === inputAnchor);
                    connectingWires.forEach(wire => {
                        if (wire.start) {
                            const sourceComp = wire.start.closest('.component');
                            if (sourceComp) {
                                const state = getComponentOutputState(sourceComp, wire.start);
                                // 处理多位数据，转换为十进制值
                                if (Array.isArray(state)) {
                                    const decimalValue = state.reduce((acc, bit, index) => {
                                        return acc + bit * Math.pow(2, state.length - 1 - index);
                                    }, 0);
                                    signalSources.push(decimalValue);
                                } else {
                                    signalSources.push(state);
                                }
                            }
                        }
                    });

                    // 设置输入值
                    if (signalSources.length > 1) {
                        inputs[pinName] = signalSources.some(state => state === 1) ? 1 : 0;
                    } else if (signalSources.length === 1) {
                        inputs[pinName] = signalSources[0];
                    } else {
                        inputs[pinName] = 0; // 默认无连接为低电平
                    }
                });

                return inputs;
            }

            // 获取74LS160组件的命名输入状态
            function get74LS160InputStates(component) {
                const inputAnchors = Array.from(component.querySelectorAll('.input-anchor'));
                const inputs = {};

                inputAnchors.forEach(inputAnchor => {
                    const pinName = inputAnchor.getAttribute('data-pin');
                    if (!pinName) return;

                    const signalSources = [];

                    // 检查直接连接的锚点
                    if (anchorConnections.has(inputAnchor)) {
                        const sourceAnchors = anchorConnections.get(inputAnchor);
                        sourceAnchors.forEach(sourceAnchor => {
                            const sourceComp = sourceAnchor.closest('.component');
                            if (sourceComp) {
                                const state = getComponentOutputState(sourceComp, sourceAnchor);
                                // 处理多位数据，转换为十进制值
                                if (Array.isArray(state)) {
                                    const decimalValue = state.reduce((acc, bit, index) => {
                                        return acc + bit * Math.pow(2, state.length - 1 - index);
                                    }, 0);
                                    signalSources.push(decimalValue);
                                } else {
                                    signalSources.push(state);
                                }
                            }
                        });
                    }

                    // 检查连线连接
                    const connectingWires = wires.filter(wire => wire.end === inputAnchor);
                    connectingWires.forEach(wire => {
                        if (wire.start) {
                            const sourceComp = wire.start.closest('.component');
                            if (sourceComp) {
                                const state = getComponentOutputState(sourceComp, wire.start);
                                if (Array.isArray(state)) {
                                    const decimalValue = state.reduce((acc, bit, index) => {
                                        return acc + bit * Math.pow(2, state.length - 1 - index);
                                    }, 0);
                                    signalSources.push(decimalValue);
                                } else {
                                    signalSources.push(state);
                                }
                            }
                        }
                    });

                    // 设置输入值
                    if (signalSources.length > 1) {
                        inputs[pinName] = signalSources.some(state => state === 1) ? 1 : 0;
                    } else if (signalSources.length === 1) {
                        inputs[pinName] = signalSources[0];
                    } else {
                        inputs[pinName] = 0; // 默认无连接为低电平
                    }
                });

                return inputs;
            }

            // 获取74LS280组件的命名输入状态
            function get74280InputStates(component) {
                const inputAnchors = Array.from(component.querySelectorAll('.input-anchor'));
                const inputs = {};

                inputAnchors.forEach(inputAnchor => {
                    const pinName = inputAnchor.getAttribute('data-pin');
                    if (!pinName) return;

                    const signalSources = [];

                    // 检查直接连接的锚点
                    if (anchorConnections.has(inputAnchor)) {
                        const sourceAnchors = anchorConnections.get(inputAnchor);
                        sourceAnchors.forEach(sourceAnchor => {
                            const sourceComp = sourceAnchor.closest('.component');
                            if (sourceComp) {
                                const state = getComponentOutputState(sourceComp, sourceAnchor);
                                signalSources.push(state);
                            }
                        });
                    }

                    // 检查连线连接
                    const connectingWires = wires.filter(wire => wire.end === inputAnchor);
                    connectingWires.forEach(wire => {
                        if (wire.start) {
                            const sourceComp = wire.start.closest('.component');
                            if (sourceComp) {
                                const state = getComponentOutputState(sourceComp, wire.start);
                                signalSources.push(state);
                            }
                        }
                    });

                    // 设置输入值（对于74LS280，所有输入都是单比特）
                    if (signalSources.length > 1) {
                        inputs[pinName] = signalSources.some(state => state === 1) ? 1 : 0;
                    } else if (signalSources.length === 1) {
                        inputs[pinName] = signalSources[0] || 0;
                    } else {
                        inputs[pinName] = 0; // 默认无连接为低电平
                    }
                });

                return inputs;
            }

            // 获取74139组件的命名输入状态
            function get74139InputStates(component) {
                const inputAnchors = Array.from(component.querySelectorAll('.input-anchor'));
                const inputs = {};

                inputAnchors.forEach(inputAnchor => {
                    const pinName = inputAnchor.getAttribute('data-pin');
                    if (!pinName) return;

                    const signalSources = [];

                    // 检查直接连接的锚点
                    if (anchorConnections.has(inputAnchor)) {
                        const sourceAnchors = anchorConnections.get(inputAnchor);
                        sourceAnchors.forEach(sourceAnchor => {
                            const sourceComp = sourceAnchor.closest('.component');
                            if (sourceComp) {
                                const sourceType = sourceComp.dataset.type;
                                const sourceId = sourceComp.dataset.id;
                                const sourceState = getComponentOutputState(sourceComp, sourceAnchor);
                                signalSources.push(sourceState);
                            }
                        });
                    }

                    // 检查连线连接
                    const connectingWires = wires.filter(wire => wire.end === inputAnchor);
                    connectingWires.forEach(wire => {
                        if (wire.start) {
                            const sourceComp = wire.start.closest('.component');
                            if (sourceComp) {
                                const sourceState = getComponentOutputState(sourceComp, wire.start);
                                signalSources.push(sourceState);
                            }
                        }
                    });

                    // 设置输入值（对于74139，所有输入都是单比特）
                    if (signalSources.length > 1) {
                        inputs[pinName] = signalSources.some(state => state === 1) ? 1 : 0;
                    } else if (signalSources.length === 1) {
                        inputs[pinName] = signalSources[0] || 0;
                    } else {
                        inputs[pinName] = 0; // 默认无连接为低电平
                    }
                });

                return inputs;
            }

            // 获取模N计数器组件的命名输入状态
            function getModNCounterInputStates(component) {
                const inputAnchors = Array.from(component.querySelectorAll('.input-anchor'));
                const inputs = {};

                inputAnchors.forEach(inputAnchor => {
                    const pinName = inputAnchor.getAttribute('data-pin');
                    if (!pinName) return;

                    const signalSources = [];

                    // 检查直接连接的锚点
                    if (anchorConnections.has(inputAnchor)) {
                        const connectedAnchors = anchorConnections.get(inputAnchor);
                        for (const connectedAnchor of connectedAnchors) {
                            const sourceComponent = connectedAnchor.closest('.component');
                            if (sourceComponent) {
                                const sourceState = getComponentOutputState(sourceComponent, connectedAnchor);
                                signalSources.push(sourceState);
                            }
                        }
                    }

                    // 检查分支连线连接
                    const branchWires = wires.filter(wire => wire.end === inputAnchor);
                    for (const wire of branchWires) {
                        if (wire.branchFrom) {
                            const originalWire = wires.find(w => w.line === wire.branchFrom);
                            if (originalWire && originalWire.start) {
                                const sourceComponent = originalWire.start.closest('.component');
                                if (sourceComponent) {
                                    const sourceState = getComponentOutputState(sourceComponent, originalWire.start);
                                    signalSources.push(sourceState);
                                }
                            }
                        }
                    }

                    // 设置输入值
                    if (signalSources.length > 1) {
                        inputs[pinName] = signalSources.some(state => state === 1) ? 1 : 0;
                    } else if (signalSources.length === 1) {
                        inputs[pinName] = signalSources[0];
                    } else {
                        // 对于CLR'信号，默认为高电平（不清零）；其他信号默认为低电平
                        inputs[pinName] = (pinName === 'CLR') ? 1 : 0;
                    }
                });

                // 获取模数配置
                const componentId = component.dataset.id;
                const currentState = componentStates.get(componentId) || {};
                inputs.MOD = currentState.modValue || 5; // 默认模5

                return inputs;
            }

            // 获取二进制异步计数器组件的命名输入状态
            function getBinaryAsyncCounterInputStates(component) {
                const inputAnchors = Array.from(component.querySelectorAll('.input-anchor'));
                const inputs = {};

                inputAnchors.forEach(inputAnchor => {
                    const pinName = inputAnchor.getAttribute('data-pin');
                    if (!pinName) return;

                    const signalSources = [];

                    // 检查直接连接的锚点
                    if (anchorConnections.has(inputAnchor)) {
                        const connectedAnchors = anchorConnections.get(inputAnchor);
                        for (const connectedAnchor of connectedAnchors) {
                            const sourceComponent = connectedAnchor.closest('.component');
                            if (sourceComponent) {
                                const sourceState = getComponentOutputState(sourceComponent, connectedAnchor);
                                signalSources.push(sourceState);
                            }
                        }
                    }

                    // 检查分支连线连接
                    const branchWires = wires.filter(wire => wire.end === inputAnchor);
                    for (const wire of branchWires) {
                        if (wire.branchFrom) {
                            const originalWire = wires.find(w => w.line === wire.branchFrom);
                            if (originalWire && originalWire.start) {
                                const sourceComponent = originalWire.start.closest('.component');
                                if (sourceComponent) {
                                    const sourceState = getComponentOutputState(sourceComponent, originalWire.start);
                                    signalSources.push(sourceState);
                                }
                            }
                        }
                    }

                    // 设置输入值
                    if (signalSources.length > 1) {
                        inputs[pinName] = signalSources.some(state => state === 1) ? 1 : 0;
                    } else if (signalSources.length === 1) {
                        inputs[pinName] = signalSources[0];
                    } else {
                        // RST'默认为高电平（不复位），CLK默认为低电平
                        inputs[pinName] = (pinName === 'RST') ? 1 : 0;
                    }
                });

                return inputs;
            }

            // 获取多数表决器组件的命名输入状态
            function getMajorityVoterInputStates(component) {
                const inputAnchors = Array.from(component.querySelectorAll('.input-anchor'));
                const inputs = {};
                const inputLabels = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];

                inputAnchors.forEach((inputAnchor, index) => {
                    const pinName = inputAnchor.getAttribute('data-pin') || inputLabels[index];
                    const signalSources = [];

                    // 检查直接连接的锚点
                    if (anchorConnections.has(inputAnchor)) {
                        const connectedAnchors = anchorConnections.get(inputAnchor);
                        for (const connectedAnchor of connectedAnchors) {
                            const sourceComponent = connectedAnchor.closest('.component');
                            if (sourceComponent) {
                                const sourceState = getComponentOutputState(sourceComponent, connectedAnchor);
                                signalSources.push(sourceState);
                            }
                        }
                    }

                    // 检查分支连线连接
                    const branchWires = wires.filter(wire => wire.end === inputAnchor);
                    for (const wire of branchWires) {
                        if (wire.branchFrom) {
                            const originalWire = wires.find(w => w.line === wire.branchFrom);
                            if (originalWire && originalWire.start) {
                                const sourceComponent = originalWire.start.closest('.component');
                                if (sourceComponent) {
                                    const sourceState = getComponentOutputState(sourceComponent, originalWire.start);
                                    signalSources.push(sourceState);
                                }
                            }
                        }
                    }

                    // 设置输入值
                    if (signalSources.length > 1) {
                        inputs[pinName] = signalSources.some(state => state === 1) ? 1 : 0;
                    } else if (signalSources.length === 1) {
                        inputs[pinName] = signalSources[0];
                    } else {
                        inputs[pinName] = 0; // 默认为低电平
                    }
                });

                return inputs;
            }

            // 获取74LS153组件的命名输入状态
            function get74LS153InputStates(component) {
                const inputAnchors = Array.from(component.querySelectorAll('.input-anchor'));
                const inputs = {};

                console.log('74LS153输入状态获取 - 找到锚点数量:', inputAnchors.length);

                inputAnchors.forEach(inputAnchor => {
                    const pinName = inputAnchor.getAttribute('data-pin');
                    const signalSources = [];

                    console.log(`检查引脚 ${pinName}:`);

                    // 检查直接连接的锚点
                    if (anchorConnections.has(inputAnchor)) {
                        const connectedAnchors = anchorConnections.get(inputAnchor);
                        console.log(`  - 直接连接的锚点数量: ${connectedAnchors ? connectedAnchors.size : 0}`);
                        if (connectedAnchors) {
                            for (const connectedAnchor of connectedAnchors) {
                                const sourceComponent = connectedAnchor.closest('.component');
                                if (sourceComponent) {
                                    const sourceState = getComponentOutputState(sourceComponent, connectedAnchor);
                                    signalSources.push(sourceState);
                                    console.log(`  - 直接连接源状态: ${sourceState}`);
                                }
                            }
                        }
                    } else {
                        console.log(`  - 直接连接的锚点数量: 0`);
                    }

                    // 检查通过连线连接的信号
                    const connectingWires = wires.filter(wire => wire.end === inputAnchor);
                    console.log(`  - 连线数量: ${connectingWires.length}`);
                    connectingWires.forEach(wire => {
                        if (wire.start) {
                            const sourceComponent = wire.start.closest('.component');
                            if (sourceComponent) {
                                const sourceState = getComponentOutputState(sourceComponent, wire.start);
                                signalSources.push(sourceState);
                                console.log(`  - 连线源状态: ${sourceState}`);
                            }
                        }
                    });

                    // 设置输入值
                    if (signalSources.length > 1) {
                        inputs[pinName] = signalSources.some(state => state === 1) ? 1 : 0;
                    } else if (signalSources.length === 1) {
                        inputs[pinName] = signalSources[0];
                    } else {
                        inputs[pinName] = 0; // 默认为低电平
                    }

                    console.log(`  - 最终值: ${inputs[pinName]}`);
                });

                console.log('74LS153最终输入状态:', inputs);
                return inputs;
            }

            // 更新元件显示
            function updateComponentDisplay(component, state) {
                const type = component.dataset.type;
                const id = component.dataset.id;

                if (type === 'output') {
                    // 使用统一的端口显示更新函数
                    updatePortDisplay(id);
                } else if (type === 'd-flipflop') {
                    // 更新D触发器的显示状态
                    const qText = component.querySelector('text[x="185"][y="55"]');
                    const qBarText = component.querySelector('text[x="185"][y="75"]');

                    if (qText) {
                        qText.textContent = `Q=${state}`;
                    }
                    if (qBarText) {
                        qBarText.textContent = `Q̄=${1-state}`;
                    }

                    // 可以添加颜色变化来表示状态
                    const rect = component.querySelector('rect');
                    if (rect) {
                        rect.setAttribute('fill', state ? '#e8f5e8' : '#f5e8e8');
                    }
                } else if (['pin', 'splitter', 'probe', 'power', 'ground'].includes(type)) {
                    // 线路组件显示更新
                    if (type === 'pin') {
                        // 引脚显示更新
                        const pinMode = component.dataset.pinMode || 'input';
                        if (pinMode === 'output') {
                            // 输出模式的引脚显示接收到的值
                            console.log(`引脚 ${id} (输出模式) 接收到值: ${state}`);
                            if (window.CircuitComponents && window.CircuitComponents.updatePinDisplay) {
                                window.CircuitComponents.updatePinDisplay(component, state);
                            }
                        } else {
                            // 输入模式的引脚显示设置的值
                            const pinValue = parseInt(component.dataset.pinValue || '0');
                            if (window.CircuitComponents && window.CircuitComponents.updatePinDisplay) {
                                window.CircuitComponents.updatePinDisplay(component, pinValue);
                            }
                        }
                    } else if (type === 'probe') {
                        // 探针显示更新
                        if (window.CircuitComponents && window.CircuitComponents.updateProbeDisplay) {
                            window.CircuitComponents.updateProbeDisplay(component, state);
                        }
                    }
                    // 其他线路组件的显示更新可以在这里添加
                } else if (type === 'led-diode') {
                    // LED二极管显示更新
                    updateLEDDisplay(component, state);
                    // 不再调用外部组件的更新函数，避免冲突
                } else if (type === '74139') {
                    // 74139数据分配器显示更新
                    update74139Display(component, state);
                } else if (['jk-flipflop', 't-flipflop', 'tp-flipflop', 'counter', 'rs-latch'].includes(type)) {
                    // 时序逻辑组件显示更新
                    if (type === 'jk-flipflop' && window.JKFlipFlopComponent && window.JKFlipFlopComponent.updateDisplay) {
                        window.JKFlipFlopComponent.updateDisplay(component, state);
                    } else if (type === 't-flipflop' && window.TFlipFlopComponent && window.TFlipFlopComponent.updateDisplay) {
                        window.TFlipFlopComponent.updateDisplay(component, state);
                    } else if (type === 'tp-flipflop' && window.TPFlipFlopComponent && window.TPFlipFlopComponent.updateDisplay) {
                        window.TPFlipFlopComponent.updateDisplay(component, state);
                    } else if (type === 'counter' && window.CounterComponent && window.CounterComponent.updateDisplay) {
                        window.CounterComponent.updateDisplay(component, state);
                    } else if (type === 'rs-latch' && window.RSLatchComponent && window.RSLatchComponent.updateDisplay) {
                        window.RSLatchComponent.updateDisplay(component, state);
                    }
                }
            }

            // 更新74139数据分配器显示
            function update74139Display(component, state) {
                if (!state) return;

                // 更新所有输出锚点的颜色
                const outputAnchors = component.querySelectorAll('.output-anchor');
                outputAnchors.forEach(anchor => {
                    const pinName = anchor.getAttribute('data-pin');
                    if (pinName && state[pinName] !== undefined) {
                        // 根据输出状态设置颜色：0=绿色(低电平)，1=红色(高电平)
                        anchor.setAttribute('fill', state[pinName] === 0 ? 'green' : 'red');
                    }
                });

                console.log(`74139显示更新: Y0=${state.Y0}, Y1=${state.Y1}, Y2=${state.Y2}, Y3=${state.Y3}`);
            }

            // 更新运算器组件显示
            function updateArithmeticComponentDisplay(component, state, type) {
                if (type === 'adder') {
                    // 更新加法器显示
                    const sumText = component.querySelector('text[x="185"][y="55"]');
                    const carryText = component.querySelector('text[x="185"][y="75"]');

                    if (sumText) sumText.textContent = `S=${state.sum}`;
                    if (carryText) carryText.textContent = `Cout=${state.carry}`;
                } else if (type === 'subtractor') {
                    // 更新减法器显示
                    const diffText = component.querySelector('text[x="185"][y="55"]');
                    const borrowText = component.querySelector('text[x="185"][y="75"]');

                    if (diffText) diffText.textContent = `D=${state.difference}`;
                    if (borrowText) borrowText.textContent = `Bout=${state.borrow}`;
                } else if (type === 'divider') {
                    // 更新除法器显示
                    const quotientText = component.querySelector('text[x="185"][y="55"]');
                    const remainderText = component.querySelector('text[x="185"][y="75"]');

                    if (quotientText) quotientText.textContent = `Q=${state.quotient}`;
                    if (remainderText) remainderText.textContent = `R=${state.remainder}`;
                }
            }

            // 时钟信号管理
            const clockIntervals = new Map(); // 存储每个时钟的定时器
            const clockPreviousStates = new Map(); // 存储时钟的前一个状态，用于边沿检测

            // 启动时钟信号
            function startClockSignal(clockComponent) {
                const id = clockComponent.dataset.id;
                const frequency = 1000; // 1秒周期

                // 清除可能存在的旧定时器
                if (clockIntervals.has(id)) {
                    clearInterval(clockIntervals.get(id));
                }

                // 创建新的定时器
                const interval = setInterval(() => {
                    const currentState = componentStates.get(id);
                    const previousState = clockPreviousStates.get(id) || 0;
                    const newState = currentState === 0 ? 1 : 0;

                    // 先进行边沿检测（在更新前状态之前）
                    const isRisingEdge = previousState === 0 && newState === 1;
                    const isFallingEdge = previousState === 1 && newState === 0;

                    // 然后更新状态
                    componentStates.set(id, newState);
                    // 更新前状态为新状态（供下次边沿检测使用）
                    clockPreviousStates.set(id, newState);

                    // 更新时钟显示
                    const bgElement = clockComponent.querySelector('#clock-bg');
                    if (bgElement) {
                        if (newState === 1) {
                            bgElement.classList.add('clock-active');
                        } else {
                            bgElement.classList.remove('clock-active');
                        }
                    }

                    if (isRisingEdge || isFallingEdge) {

                        // 记录时钟边沿事件
                        clockEdgeDetection.set(id, {
                            edgeType: isRisingEdge ? 'rising' : 'falling',
                            timestamp: Date.now(),
                            clockState: newState
                        });

                        // 处理时序逻辑更新（延迟执行，模拟真实的传播延迟）
                        setTimeout(() => {
                            // 触发时钟事件，供外部组件监听
                            const clockTickEvent = new CustomEvent('clock-tick', {
                                detail: {
                                    component: clockComponent,
                                    state: newState,
                                    previousState: previousState,
                                    edgeType: isRisingEdge ? 'rising' : 'falling'
                                }
                            });
                            document.dispatchEvent(clockTickEvent);

                            processSequentialLogic(clockComponent, isRisingEdge ? 'rising' : 'falling');
                        }, 5); // 减少延迟到5ms
                    }

                    // 对于组合逻辑元件，使用普通的信号传播
                    propagateSignal(clockComponent);
                }, frequency);

                clockIntervals.set(id, interval);
            }

            // 真正的时序逻辑处理函数
            function processSequentialLogic(clockComponent, edgeType) {
                // 找到所有连接到此时钟的时序元件
                const connectedSequentialElements = findConnectedSequentialElements(clockComponent);

                // 去重处理，避免重复处理同一个元件
                const processedElements = new Set();
                connectedSequentialElements.forEach(element => {
                    const elementType = element.dataset.type;
                    const elementId = element.dataset.id;

                    if (processedElements.has(elementId)) {
                        return;
                    }

                    processedElements.add(elementId);

                    if (elementType === 'd-flipflop') {
                        processDFlipFlop(element, edgeType);
                    } else if (elementType === 'jk-flipflop') {
                        processJKFlipFlop(element, edgeType);
                    } else if (elementType === 't-flipflop') {
                        processTFlipFlop(element, edgeType);
                    } else if (elementType === 'tp-flipflop') {
                        processTPFlipFlop(element, edgeType);
                    } else if (elementType === 'counter') {
                        processCounter(element, edgeType);
                    } else if (elementType === 'rs-latch') {
                        processRSLatch(element, edgeType);
                    }
                });
            }

            // 查找连接到时钟的时序元件
            function findConnectedSequentialElements(clockComponent) {
                const connectedElements = [];
                const outputAnchors = Array.from(clockComponent.querySelectorAll('.output-anchor'));

                outputAnchors.forEach(anchor => {
                    // 检查直接连接 - 支持多个连接
                    if (anchorConnections.has(anchor)) {
                        const targetAnchors = anchorConnections.get(anchor);
                        targetAnchors.forEach(targetAnchor => {
                            const targetComponent = targetAnchor.closest('.component');
                            const targetType = targetComponent.dataset.type;

                            // 检查目标锚点是否是时钟输入
                            if (isSequentialElement(targetType) && isClockInput(targetAnchor)) {
                                connectedElements.push(targetComponent);
                            }
                        });
                    }

                    // 检查通过连线的连接
                    wires.forEach(wire => {
                        if (wire.start === anchor && wire.end) {
                            const targetComponent = wire.end.closest('.component');
                            const targetType = targetComponent.dataset.type;

                            if (isSequentialElement(targetType) && isClockInput(wire.end)) {
                                connectedElements.push(targetComponent);
                            }
                        }
                    });
                });

                return connectedElements;
            }

            // JK触发器处理函数
            function processJKFlipFlop(element, edgeType) {
                const elementId = element.dataset.id;
                const state = sequentialElements.get(elementId);
                if (!state) {
                    console.error(`JK触发器 ${elementId} 状态未找到`);
                    return;
                }

                console.log(`JK触发器 ${elementId} 收到时钟边沿: ${edgeType}`);

                if (edgeType === 'rising') {
                    // 获取J和K输入
                    const jInput = getInputValue(element, 0) || 0; // J输入
                    const kInput = getInputValue(element, 1) || 0; // K输入

                    console.log(`JK触发器 ${elementId} 输入值: J=${jInput}, K=${kInput}, 当前状态: Q=${state.q}, Q̄=${state.qBar}`);

                    // 记录之前的状态
                    const prevQ = state.q;
                    const prevQBar = state.qBar;

                    // JK触发器逻辑
                    if (jInput === 0 && kInput === 0) {
                        // 保持状态
                        console.log(`JK触发器 ${elementId}: J=0, K=0 - 保持状态`);
                    } else if (jInput === 0 && kInput === 1) {
                        // 复位
                        state.q = 0;
                        state.qBar = 1;
                        console.log(`JK触发器 ${elementId}: J=0, K=1 - 复位`);
                    } else if (jInput === 1 && kInput === 0) {
                        // 置位
                        state.q = 1;
                        state.qBar = 0;
                        console.log(`JK触发器 ${elementId}: J=1, K=0 - 置位`);
                    } else if (jInput === 1 && kInput === 1) {
                        // 翻转
                        const newQ = 1 - state.q;
                        state.q = newQ;
                        state.qBar = 1 - newQ;
                        console.log(`JK触发器 ${elementId}: J=1, K=1 - 翻转状态从 Q=${prevQ} 到 Q=${state.q}`);
                    }

                    // 保存状态到全局映射
                    sequentialElements.set(elementId, state);
                    console.log(`JK触发器 ${elementId} 状态已保存:`, sequentialElements.get(elementId));

                    // 更新显示
                    updateJKFlipFlopDisplay(element, state.q, state.qBar);
                    componentStates.set(elementId, state.q);

                    console.log(`JK触发器 ${elementId} 时钟上升沿处理完成: J=${jInput}, K=${kInput}, Q=${state.q}, Q̄=${state.qBar}`);

                    // 传播输出信号到连接的组件
                    propagateSequentialOutputs(element, state.q, state.qBar);
                }
            }

            // 传播时序元件输出信号的通用函数
            function propagateSequentialOutputs(element, qValue, qBarValue) {
                const outputAnchors = element.querySelectorAll('.output-anchor');
                if (outputAnchors.length >= 2) {
                    const qAnchor = outputAnchors[0]; // Q输出
                    const qBarAnchor = outputAnchors[1]; // Q̄输出

                    console.log(`传播时序输出: Q=${qValue}, Q̄=${qBarValue}`);

                    // 传播Q输出
                    propagateSignalFromSequentialAnchor(qAnchor, qValue);
                    // 传播Q̄输出
                    propagateSignalFromSequentialAnchor(qBarAnchor, qBarValue);
                }
            }

            // 从时序元件锚点传播信号的辅助函数
            function propagateSignalFromSequentialAnchor(anchor, value) {
                // 检查直接连接的锚点
                if (anchorConnections.has(anchor)) {
                    const connectedAnchors = anchorConnections.get(anchor);
                    for (const connectedAnchor of connectedAnchors) {
                        const targetComponent = connectedAnchor.closest('.component');
                        if (targetComponent) {
                            const targetId = targetComponent.dataset.id;
                            const targetType = targetComponent.dataset.type;

                            console.log(`传播信号 ${value} 从时序锚点到组件 ${targetType} (${targetId})`);

                            if (targetType === 'output') {
                                // 更新输出组件
                                componentStates.set(targetId, value);
                                updateOutputDisplay(targetComponent, value);
                            } else {
                                // 对其他组件触发信号传播
                                propagateSignal(targetComponent);
                            }
                        }
                    }
                }

                // 检查连线连接
                for (const wire of wires) {
                    if (wire.start === anchor && wire.end) {
                        const targetComponent = wire.end.closest('.component');
                        if (targetComponent) {
                            const targetId = targetComponent.dataset.id;
                            const targetType = targetComponent.dataset.type;

                            console.log(`通过连线传播信号 ${value} 到组件 ${targetType} (${targetId})`);

                            if (targetType === 'output') {
                                // 更新输出组件
                                componentStates.set(targetId, value);
                                updateOutputDisplay(targetComponent, value);
                            } else {
                                // 对其他组件触发信号传播
                                propagateSignal(targetComponent);
                            }
                        }
                    }
                }
            }

            // 更新输出组件显示
            function updateOutputDisplay(outputComponent, value) {
                const textElement = outputComponent.querySelector('.state-text');
                const bgElement = outputComponent.querySelector('#output-bg');

                if (textElement) {
                    textElement.textContent = value.toString();
                }
                if (bgElement) {
                    bgElement.classList.remove('state-0', 'state-1');
                    bgElement.classList.add(value ? 'state-1' : 'state-0');
                }

                console.log(`输出组件 ${outputComponent.dataset.id} 显示更新为: ${value}`);
            }

            // T触发器处理函数
            function processTFlipFlop(element, edgeType) {
                const elementId = element.dataset.id;
                const state = sequentialElements.get(elementId);
                if (!state) {
                    console.error(`T触发器 ${elementId} 状态未找到`);
                    return;
                }

                console.log(`T触发器 ${elementId} 收到时钟边沿: ${edgeType}`);

                if (edgeType === 'rising') {
                    const tInput = getInputValue(element, 0) || 0; // T输入

                    console.log(`T触发器 ${elementId} 输入值: T=${tInput}, 当前状态: Q=${state.q}, Q̄=${state.qBar}`);

                    // 记录之前的状态
                    const prevQ = state.q;
                    const prevQBar = state.qBar;

                    // T触发器逻辑：T=1时翻转，T=0时保持
                    if (tInput === 1) {
                        const newQ = 1 - state.q;
                        state.q = newQ;
                        state.qBar = 1 - newQ;
                        console.log(`T触发器 ${elementId}: T=1 - 翻转状态从 Q=${prevQ} 到 Q=${state.q}`);
                    } else {
                        console.log(`T触发器 ${elementId}: T=0 - 保持状态 Q=${state.q}`);
                    }

                    // 保存状态到全局映射
                    sequentialElements.set(elementId, state);
                    console.log(`T触发器 ${elementId} 状态已保存:`, sequentialElements.get(elementId));

                    // 更新显示
                    updateTFlipFlopDisplay(element, state.q, state.qBar);
                    componentStates.set(elementId, state.q);

                    console.log(`T触发器 ${elementId} 时钟上升沿处理完成: T=${tInput}, Q=${state.q}, Q̄=${state.qBar}`);

                    // 传播输出信号到连接的组件
                    propagateSequentialOutputs(element, state.q, state.qBar);
                }
            }

            // T'触发器处理函数
            function processTPFlipFlop(element, edgeType) {
                const elementId = element.dataset.id;
                const state = sequentialElements.get(elementId);
                if (!state) {
                    console.error(`T'触发器 ${elementId} 状态未找到`);
                    return;
                }

                console.log(`T'触发器 ${elementId} 收到时钟边沿: ${edgeType}`);

                // T'触发器在时钟下降沿触发
                if (edgeType === 'falling') {
                    console.log(`T'触发器 ${elementId} 当前状态: Q=${state.q}, Q̄=${state.qBar}`);

                    // 记录之前的状态
                    const prevQ = state.q;
                    const prevQBar = state.qBar;

                    // T'触发器逻辑：每个时钟下降沿都翻转状态（相当于T=1的T触发器在下降沿触发）
                    const newQ = 1 - state.q;
                    state.q = newQ;
                    state.qBar = 1 - newQ;
                    console.log(`T'触发器 ${elementId}: 时钟下降沿 - 翻转状态从 Q=${prevQ} 到 Q=${state.q}`);

                    // 保存状态到全局映射
                    sequentialElements.set(elementId, state);
                    console.log(`T'触发器 ${elementId} 状态已保存:`, sequentialElements.get(elementId));

                    // 更新显示
                    updateTPFlipFlopDisplay(element, state.q, state.qBar);
                    componentStates.set(elementId, state.q);

                    console.log(`T'触发器 ${elementId} 时钟下降沿处理完成: Q=${state.q}, Q̄=${state.qBar}`);

                    // 传播输出信号到连接的组件
                    propagateSequentialOutputs(element, state.q, state.qBar);
                }
            }

            // 计数器处理函数
            function processCounter(element, edgeType) {
                const elementId = element.dataset.id;
                const state = sequentialElements.get(elementId);
                if (!state) {
                    console.error(`计数器 ${elementId} 状态未找到`);
                    return;
                }

                if (edgeType === 'rising') {
                    // 检查复位输入（R端口）
                    const resetInput = getInputValue(element, 0) || 0;  // R输入（复位端口）

                    if (resetInput === 1) {
                        // 复位输入为1时，计数器值重置为0
                        const prevCount = state.count;
                        state.count = 0;
                        console.log(`计数器 ${elementId}: R=1 - 复位 ${prevCount}→${state.count}`);

                        // 保存状态并更新显示
                        sequentialElements.set(elementId, state);
                        updateCounterDisplay(element, state.count);
                        componentStates.set(elementId, state.count);
                        propagateCounterOutputs(element, state.count, 0);
                        return;
                    }

                    // 如果没有复位，则正常计数（递增）
                    const prevCount = state.count;
                    const maxValue = getCounterMaxValue(element);
                    const overflowAction = getCounterOverflowAction(element);

                    if (state.count >= maxValue) {
                        // 处理溢出
                        handleCounterOverflow(state, overflowAction, maxValue, 0, true);
                        console.log(`计数器 ${elementId}: 递增溢出处理 ${prevCount}→${state.count}`);
                    } else {
                        state.count++;
                        console.log(`计数器 ${elementId}: 正常递增 ${prevCount}→${state.count}`);
                    }

                    console.log(`计数器 ${elementId} 时钟上升沿: R=${resetInput}, 当前值=${state.count}`);

                    // 计算carry输出
                    const carryOutput = (state.count >= maxValue) ? 1 : 0;
                    state.carry = carryOutput;

                    // 保存状态
                    sequentialElements.set(elementId, state);

                    // 更新显示
                    updateCounterDisplay(element, state.count);
                    componentStates.set(elementId, state.count);

                    console.log(`计数器 ${elementId} 处理完成: 最终值=${state.count}, carry=${carryOutput}`);

                    // 传播输出信号（包括carry输出）
                    propagateCounterOutputs(element, state.count, carryOutput);
                }
            }

            // 传播计数器的输出信号
            function propagateCounterOutputs(counterComponent, countValue, carryValue) {
                const elementId = counterComponent.dataset.id;
                console.log(`传播计数器 ${elementId} 输出: count=${countValue}, carry=${carryValue}`);

                // 查找计数器的输出锚点
                const outputAnchors = Array.from(counterComponent.querySelectorAll('.output-anchor'));

                outputAnchors.forEach((anchor, index) => {
                    let outputValue;

                    // 根据锚点位置确定输出类型
                    const anchorY = parseInt(anchor.getAttribute('cy'));

                    if (outputAnchors.length === 1) {
                        // 只有一个输出锚点，输出计数值
                        outputValue = countValue;
                        console.log(`计数器单输出: count=${outputValue}`);
                    } else if (outputAnchors.length === 2) {
                        // 两个输出锚点：上面是计数值，下面是carry
                        if (index === 0 || anchorY <= 55) {
                            outputValue = countValue;
                            console.log(`计数器主输出: count=${outputValue}`);
                        } else {
                            outputValue = carryValue;
                            console.log(`计数器carry输出: carry=${outputValue}`);
                        }
                    } else {
                        // 多个输出锚点，默认都输出计数值
                        outputValue = countValue;
                        console.log(`计数器多输出 ${index}: count=${outputValue}`);
                    }

                    // 传播信号到连接的组件
                    propagateSignalFromSequentialAnchor(anchor, outputValue);
                });
            }

            // 获取计数器最大值
            function getCounterMaxValue(element) {
                // 从元素的数据属性中获取最大值，默认为15（4位计数器）
                const maxValue = parseInt(element.dataset.maxValue) || 15;
                console.log(`计数器最大值: ${maxValue}`);
                return maxValue;
            }

            // 获取计数器溢出行为
            function getCounterOverflowAction(element) {
                // 从元素的数据属性中获取溢出行为，默认为"wrap"
                const action = element.dataset.overflowAction || 'wrap';
                console.log(`计数器溢出行为: ${action}`);
                return action;
            }

            // 处理计数器溢出
            function handleCounterOverflow(state, overflowAction, maxValue, dataInput, isIncrement) {
                console.log(`处理计数器溢出: 动作=${overflowAction}, 最大值=${maxValue}, 数据输入=${dataInput}, 递增=${isIncrement}`);

                switch (overflowAction) {
                    case 'wrap':
                        // Wrap around 重新计数
                        if (isIncrement) {
                            // 递增时，下一个值是0
                            state.count = 0;
                            console.log('递增溢出：重新计数，设置为0');
                        } else {
                            // 递减时，下一个值是最大值
                            state.count = maxValue;
                            console.log(`递减下溢：重新计数，设置为最大值${maxValue}`);
                        }
                        break;

                    case 'stay':
                        // Stay at value 保持当前值
                        if (isIncrement) {
                            // 递增时，保持最大值不变
                            state.count = maxValue;
                            console.log(`递增溢出：保持最大值${maxValue}`);
                        } else {
                            // 递减时，保持0不变
                            state.count = 0;
                            console.log('递减下溢：保持0');
                        }
                        break;

                    case 'continue':
                        // Continue counting 继续计数（保持数据位属性提供的位数）
                        // 这种模式下计数器继续递增/递减，保持数据位属性提供的位数
                        if (isIncrement) {
                            state.count++;
                        } else {
                            state.count--;
                        }
                        console.log(`继续计数模式：新值=${state.count}`);
                        break;

                    case 'load':
                        // Load next value 加载下一个值
                        // 下一个值从D输入中加载
                        state.count = dataInput;
                        console.log(`加载下一个值：从D输入加载${dataInput}`);
                        break;

                    default:
                        // 默认使用wrap行为
                        if (isIncrement) {
                            state.count = 0;
                        } else {
                            state.count = maxValue;
                        }
                        console.log(`默认溢出处理：${isIncrement ? '设置为0' : '设置为最大值' + maxValue}`);
                        break;
                }
            }

            // RS锁存器处理函数
            function processRSLatch(element, triggerType) {
                const elementId = element.dataset.id;
                const state = sequentialElements.get(elementId);
                if (!state) {
                    console.error(`RS锁存器 ${elementId} 状态未找到`);
                    return;
                }

                // RS锁存器是电平触发，响应输入信号的电平变化
                const rInput = getInputValue(element, 0) || 0; // R输入（复位）
                const sInput = getInputValue(element, 1) || 0; // S输入（置位）

                console.log(`RS锁存器 ${elementId} 触发类型: ${triggerType}, 输入: R=${rInput}, S=${sInput}, 当前状态: Q=${state.q}, Q̄=${state.qBar}`);

                // 记录之前的状态
                const prevQ = state.q;
                const prevQBar = state.qBar;

                // RS锁存器逻辑（根据特性表）
                if (rInput === 0 && sInput === 0) {
                    // 保持状态（无变化）
                    console.log(`RS锁存器 ${elementId}: R=0, S=0 - 保持状态 Q=${state.q}`);
                } else if (rInput === 0 && sInput === 1) {
                    // 置位：Q=1, Q̄=0
                    state.q = 1;
                    state.qBar = 0;
                    console.log(`RS锁存器 ${elementId}: R=0, S=1 - 置位 Q=${prevQ}→${state.q}`);
                } else if (rInput === 1 && sInput === 0) {
                    // 复位：Q=0, Q̄=1
                    state.q = 0;
                    state.qBar = 1;
                    console.log(`RS锁存器 ${elementId}: R=1, S=0 - 复位 Q=${prevQ}→${state.q}`);
                } else if (rInput === 1 && sInput === 1) {
                    // 不定状态（通常避免使用）
                    console.warn(`RS锁存器 ${elementId}: R=1, S=1 - 不定状态！这种输入组合应该避免`);
                    // 在实际电路中，这种状态可能导致不可预测的结果
                    // 这里我们保持当前状态不变
                }

                // 检查状态是否发生变化
                const stateChanged = (state.q !== prevQ) || (state.qBar !== prevQBar);

                // 保存状态到全局映射
                sequentialElements.set(elementId, state);
                console.log(`RS锁存器 ${elementId} 状态已保存:`, sequentialElements.get(elementId));

                // 更新显示
                updateRSLatchDisplay(element, state.q, state.qBar);
                componentStates.set(elementId, state.q);

                console.log(`RS锁存器 ${elementId} 处理完成: R=${rInput}, S=${sInput}, Q=${state.q}, Q̄=${state.qBar}, 状态变化: ${stateChanged}`);

                // 只有当状态发生变化时才传播输出信号，避免无限循环
                if (stateChanged) {
                    console.log(`RS锁存器 ${elementId} 状态发生变化，传播输出信号`);
                    propagateSequentialOutputs(element, state.q, state.qBar);
                }
            }

            // 判断是否是时序元件
            function isSequentialElement(componentType) {
                return ['d-flipflop', 'jk-flipflop', 't-flipflop', 'tp-flipflop', 'counter', 'rs-latch'].includes(componentType);
            }

            // 判断是否是时钟输入锚点
            function isClockInput(anchor) {
                return anchor.getAttribute('data-anchor-type') === 'clock' ||
                       anchor.classList.contains('clock-input');
            }

            // D触发器的真正时序逻辑处理
            function processDFlipFlop(flipflopComponent, edgeType) {
                const componentId = flipflopComponent.dataset.id;

                // D触发器只在上升沿触发
                if (edgeType !== 'rising') {
                    return;
                }

                // 获取D输入的当前状态
                const dInputState = getDFlipFlopInputState(flipflopComponent);

                // 获取或初始化D触发器状态
                if (!sequentialElements.has(componentId)) {
                    sequentialElements.set(componentId, {
                        q: 0,
                        qBar: 1,
                        lastD: 0,
                        lastClock: 0
                    });
                }

                const flipflopState = sequentialElements.get(componentId);

                // 在上升沿时，将D输入锁存到Q输出
                const newQ = dInputState;
                const newQBar = 1 - dInputState;

                // 更新内部状态
                flipflopState.q = newQ;
                flipflopState.qBar = newQBar;
                flipflopState.lastD = dInputState;
                flipflopState.lastClock = 1;

                // 更新组件状态（用于显示）
                componentStates.set(componentId, newQ);

                // 更新显示
                updateDFlipFlopDisplay(flipflopComponent, newQ, newQBar);

                // 传播输出信号到连接的元件
                propagateDFlipFlopOutputs(flipflopComponent, newQ, newQBar);

                // 强制刷新所有连接的输出端口显示
                setTimeout(() => {
                    refreshAllComponentDisplays();
                }, 20);
            }

            // 通用的获取输入值函数
            function getInputValue(component, inputIndex) {
                const inputAnchors = Array.from(component.querySelectorAll('.input-anchor:not(.clock-input)'));
                if (inputIndex >= inputAnchors.length) return 0;

                const anchor = inputAnchors[inputIndex];

                // 检查直接连接的锚点
                if (anchorConnections.has(anchor)) {
                    const connectedAnchors = anchorConnections.get(anchor);
                    for (const connectedAnchor of connectedAnchors) {
                        const sourceComponent = connectedAnchor.closest('.component');
                        if (sourceComponent) {
                            const sourceState = componentStates.get(sourceComponent.dataset.id);
                            if (sourceState !== undefined) {
                                return sourceState;
                            }
                        }
                    }
                }

                // 检查连线连接
                for (const wire of wires) {
                    if (wire.end === anchor && wire.start) {
                        const sourceComponent = wire.start.closest('.component');
                        if (sourceComponent) {
                            const sourceState = componentStates.get(sourceComponent.dataset.id);
                            if (sourceState !== undefined) {
                                return sourceState;
                            }
                        }
                    }
                }

                return 0; // 默认值
            }

            // 获取D触发器的D输入状态
            function getDFlipFlopInputState(flipflopComponent) {
                const inputAnchors = Array.from(flipflopComponent.querySelectorAll('.input-anchor'));

                // 找到D输入锚点（不是时钟输入）
                const dInputAnchor = inputAnchors.find(anchor =>
                    !isClockInput(anchor)
                );

                if (!dInputAnchor) {
                    return 0;
                }

                // 检查连接到D输入的信号 - 支持多个连接，取第一个有效信号
                if (anchorConnections.has(dInputAnchor)) {
                    const sourceAnchors = anchorConnections.get(dInputAnchor);
                    for (const sourceAnchor of sourceAnchors) {
                        const sourceComponent = sourceAnchor.closest('.component');
                        const state = getComponentOutputState(sourceComponent, sourceAnchor);
                        if (state !== undefined) {
                            return state;
                        }
                    }
                }

                // 检查通过连线连接的信号
                const connectedWire = wires.find(wire => wire.end === dInputAnchor);
                if (connectedWire && connectedWire.start) {
                    const sourceComponent = connectedWire.start.closest('.component');
                    return getComponentOutputState(sourceComponent, connectedWire.start);
                }

                return 0; // 默认为0
            }

            // 更新D触发器的显示
            function updateDFlipFlopDisplay(flipflopComponent, qState, qBarState) {
                // 更新组件背景色表示状态
                const rect = flipflopComponent.querySelector('rect');
                if (rect) {
                    rect.setAttribute('fill', qState ? '#e8f5e8' : '#f5e8e8');
                }

                // 可以添加文本显示当前状态
                const texts = flipflopComponent.querySelectorAll('text');
                texts.forEach(text => {
                    if (text.textContent === 'D') {
                        // 可以在这里添加D输入状态显示
                    } else if (text.textContent === 'FF') {
                        text.textContent = `Q=${qState}`;
                    }
                });
            }

            // JK触发器显示更新函数
            function updateJKFlipFlopDisplay(element, qValue, qBarValue) {
                console.log(`更新JK触发器显示: Q=${qValue}, Q̄=${qBarValue}`);

                const svg = element.querySelector('svg');
                if (!svg) {
                    console.error('JK触发器SVG元素未找到');
                    return;
                }

                // 更新组件背景色表示状态
                const rect = element.querySelector('rect');
                if (rect) {
                    const newColor = qValue ? '#e8f5e8' : '#f5e8e8';
                    rect.setAttribute('fill', newColor);
                    console.log(`JK触发器背景色更新为: ${newColor}`);
                }

                // 更新显示文本 - 查找所有可能的文本元素
                const texts = element.querySelectorAll('text');
                let textUpdated = false;
                texts.forEach(text => {
                    if (text.textContent.includes('FF') || text.textContent.includes('Q=')) {
                        text.textContent = `Q=${qValue}`;
                        textUpdated = true;
                        console.log(`JK触发器文本更新为: Q=${qValue}`);
                    }
                });

                if (!textUpdated) {
                    console.log('JK触发器文本元素未找到，尝试查找其他文本元素');
                    // 如果没有找到FF文本，尝试更新JK文本
                    texts.forEach(text => {
                        if (text.textContent === 'JK') {
                            // 在JK文本下方添加状态显示
                            const newText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            newText.setAttribute('x', text.getAttribute('x'));
                            newText.setAttribute('y', parseInt(text.getAttribute('y')) + 20);
                            newText.setAttribute('font-family', 'Arial');
                            newText.setAttribute('font-size', '12');
                            newText.setAttribute('text-anchor', 'middle');
                            newText.setAttribute('fill', 'black');
                            newText.textContent = `Q=${qValue}`;
                            svg.appendChild(newText);
                            console.log(`JK触发器添加新的状态文本: Q=${qValue}`);
                        }
                    });
                }
            }

            // T触发器显示更新函数
            function updateTFlipFlopDisplay(element, qValue, qBarValue) {
                console.log(`更新T触发器显示: Q=${qValue}, Q̄=${qBarValue}`);

                const svg = element.querySelector('svg');
                if (!svg) {
                    console.error('T触发器SVG元素未找到');
                    return;
                }

                // 更新组件背景色表示状态
                const rect = element.querySelector('rect');
                if (rect) {
                    const newColor = qValue ? '#e8f5e8' : '#f5e8e8';
                    rect.setAttribute('fill', newColor);
                    console.log(`T触发器背景色更新为: ${newColor}`);
                }

                // 更新显示文本 - 查找所有可能的文本元素
                const texts = element.querySelectorAll('text');
                let textUpdated = false;
                texts.forEach(text => {
                    if (text.textContent.includes('FF') || text.textContent.includes('Q=')) {
                        text.textContent = `Q=${qValue}`;
                        textUpdated = true;
                        console.log(`T触发器文本更新为: Q=${qValue}`);
                    }
                });

                if (!textUpdated) {
                    console.log('T触发器文本元素未找到，尝试查找其他文本元素');
                    // 如果没有找到FF文本，尝试更新T文本
                    texts.forEach(text => {
                        if (text.textContent === 'T') {
                            // 在T文本下方添加状态显示
                            const newText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            newText.setAttribute('x', text.getAttribute('x'));
                            newText.setAttribute('y', parseInt(text.getAttribute('y')) + 20);
                            newText.setAttribute('font-family', 'Arial');
                            newText.setAttribute('font-size', '12');
                            newText.setAttribute('text-anchor', 'middle');
                            newText.setAttribute('fill', 'black');
                            newText.textContent = `Q=${qValue}`;
                            svg.appendChild(newText);
                            console.log(`T触发器添加新的状态文本: Q=${qValue}`);
                        }
                    });
                }
            }

            // T'触发器显示更新函数
            function updateTPFlipFlopDisplay(element, qValue, qBarValue) {
                console.log(`更新T'触发器显示: Q=${qValue}, Q̄=${qBarValue}`);

                const svg = element.querySelector('svg');
                if (!svg) {
                    console.error('T\'触发器SVG元素未找到');
                    return;
                }

                // 更新组件背景色表示状态
                const rect = element.querySelector('rect');
                if (rect) {
                    const newColor = qValue ? '#e8f5e8' : '#f5e8e8';
                    rect.setAttribute('fill', newColor);
                    console.log(`T'触发器背景色更新为: ${newColor}`);
                }

                // 更新显示文本 - 查找所有可能的文本元素
                const texts = element.querySelectorAll('text');
                let textUpdated = false;
                texts.forEach(text => {
                    if (text.textContent.includes('FF') || text.textContent.includes('Q=')) {
                        text.textContent = `Q=${qValue}`;
                        textUpdated = true;
                        console.log(`T'触发器文本更新为: Q=${qValue}`);
                    }
                });

                if (!textUpdated) {
                    console.log('T\'触发器文本元素未找到，尝试查找其他文本元素');
                    // 如果没有找到FF文本，尝试更新T'文本
                    texts.forEach(text => {
                        if (text.textContent === 'T\'') {
                            // 在T'文本下方添加状态显示
                            const newText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            newText.setAttribute('x', text.getAttribute('x'));
                            newText.setAttribute('y', parseInt(text.getAttribute('y')) + 20);
                            newText.setAttribute('font-family', 'Arial');
                            newText.setAttribute('font-size', '12');
                            newText.setAttribute('text-anchor', 'middle');
                            newText.setAttribute('fill', 'black');
                            newText.textContent = `Q=${qValue}`;
                            svg.appendChild(newText);
                            console.log(`T'触发器添加新的状态文本: Q=${qValue}`);
                        }
                    });
                }
            }

            // 计数器显示更新函数
            function updateCounterDisplay(element, countValue) {
                console.log(`更新计数器显示: COUNT=${countValue}`);

                const svg = element.querySelector('svg');
                if (!svg) {
                    console.error('计数器SVG元素未找到');
                    return;
                }

                // 更新组件背景色
                const rect = element.querySelector('rect');
                if (rect) {
                    rect.setAttribute('fill', '#e8f4fd');
                    console.log('计数器背景色已更新');
                }

                // 获取计数器配置信息
                const maxValue = element.dataset.maxValue || '15';
                const overflowAction = element.dataset.overflowAction || 'wrap';

                // 更新计数值显示
                const texts = element.querySelectorAll('text');
                let textUpdated = false;
                texts.forEach(text => {
                    if (text.textContent.includes('计数器') || text.textContent.includes('COUNT') || text.textContent.includes('COUNTER')) {
                        text.textContent = `COUNT=${countValue}`;
                        textUpdated = true;
                        console.log(`计数器文本更新为: COUNT=${countValue}`);
                    }
                });

                if (!textUpdated) {
                    console.log('计数器文本元素未找到，尝试查找其他文本元素');
                    // 如果没有找到计数器文本，尝试添加新的文本显示
                    texts.forEach(text => {
                        if (text.textContent === 'C' || text.textContent === 'CTR') {
                            // 在现有文本下方添加计数值显示
                            const newText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            newText.setAttribute('x', text.getAttribute('x'));
                            newText.setAttribute('y', parseInt(text.getAttribute('y')) + 20);
                            newText.setAttribute('font-family', 'Arial');
                            newText.setAttribute('font-size', '10');
                            newText.setAttribute('text-anchor', 'middle');
                            newText.setAttribute('fill', 'black');
                            newText.textContent = `${countValue}`;
                            svg.appendChild(newText);
                            console.log(`计数器添加新的计数值文本: ${countValue}`);
                        }
                    });
                }

                // 添加配置信息显示（可选）
                console.log(`计数器配置: 最大值=${maxValue}, 溢出行为=${overflowAction}, 当前值=${countValue}`);
            }

            // 设置计数器配置
            function setCounterConfig(element, maxValue, overflowAction) {
                const elementId = element.dataset.id;

                // 更新元素的数据属性
                element.dataset.maxValue = maxValue.toString();
                element.dataset.overflowAction = overflowAction;

                // 更新时序元件状态
                const state = sequentialElements.get(elementId);
                if (state) {
                    state.maxValue = maxValue;
                    state.overflowAction = overflowAction;
                    sequentialElements.set(elementId, state);
                }

                console.log(`计数器 ${elementId} 配置已更新: 最大值=${maxValue}, 溢出行为=${overflowAction}`);

                // 更新显示
                updateCounterDisplay(element, state ? state.count : 0);
            }

            // 获取计数器配置信息
            function getCounterConfig(element) {
                const maxValue = parseInt(element.dataset.maxValue) || 15;
                const overflowAction = element.dataset.overflowAction || 'wrap';
                const state = sequentialElements.get(element.dataset.id);
                const currentCount = state ? state.count : 0;

                return {
                    maxValue: maxValue,
                    overflowAction: overflowAction,
                    currentCount: currentCount
                };
            }

            // RS锁存器显示更新函数
            function updateRSLatchDisplay(element, qValue, qBarValue) {
                console.log(`更新RS锁存器显示: Q=${qValue}, Q̄=${qBarValue}`);

                const svg = element.querySelector('svg');
                if (!svg) {
                    console.error('RS锁存器SVG元素未找到');
                    return;
                }

                // 更新组件背景色表示状态
                const rect = element.querySelector('rect');
                if (rect) {
                    const newColor = qValue ? '#e8f5e8' : '#f5e8e8';
                    rect.setAttribute('fill', newColor);
                    console.log(`RS锁存器背景色更新为: ${newColor}`);
                }

                // 更新显示文本 - 查找所有可能的文本元素
                const texts = element.querySelectorAll('text');
                let textUpdated = false;
                texts.forEach(text => {
                    if (text.textContent.includes('LATCH') || text.textContent.includes('Q=') || text.textContent.includes('RS')) {
                        text.textContent = `Q=${qValue}`;
                        textUpdated = true;
                        console.log(`RS锁存器文本更新为: Q=${qValue}`);
                    }
                });

                if (!textUpdated) {
                    console.log('RS锁存器文本元素未找到，尝试查找其他文本元素');
                    // 如果没有找到LATCH文本，尝试更新RS文本
                    texts.forEach(text => {
                        if (text.textContent === 'RS' || text.textContent === 'R' || text.textContent === 'S') {
                            // 在RS文本下方添加状态显示
                            const newText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            newText.setAttribute('x', text.getAttribute('x'));
                            newText.setAttribute('y', parseInt(text.getAttribute('y')) + 20);
                            newText.setAttribute('font-family', 'Arial');
                            newText.setAttribute('font-size', '12');
                            newText.setAttribute('text-anchor', 'middle');
                            newText.setAttribute('fill', 'black');
                            newText.textContent = `Q=${qValue}`;
                            svg.appendChild(newText);
                            console.log(`RS锁存器添加新的状态文本: Q=${qValue}`);
                        }
                    });
                }
            }

            // 传播D触发器的输出信号
            function propagateDFlipFlopOutputs(flipflopComponent, qState, qBarState) {
                const outputAnchors = Array.from(flipflopComponent.querySelectorAll('.output-anchor'));

                outputAnchors.forEach((anchor, index) => {
                    const outputValue = index === 0 ? qState : qBarState; // 第一个输出是Q，第二个是Q̄

                    // 传播到直接连接的锚点 - 支持多个连接
                    if (anchorConnections.has(anchor)) {
                        const targetAnchors = anchorConnections.get(anchor);
                        targetAnchors.forEach(targetAnchor => {
                            const targetComponent = targetAnchor.closest('.component');
                            const targetType = targetComponent.dataset.type;

                            // 只传播到组合逻辑元件，时序逻辑元件由时钟边沿控制
                            if (!isSequentialElement(targetType)) {
                                propagateToTarget(targetAnchor, outputValue);
                            }
                        });
                    }

                    // 传播到通过连线连接的元件
                    wires.forEach(wire => {
                        if (wire.start === anchor && wire.end) {
                            const targetComponent = wire.end.closest('.component');
                            const targetType = targetComponent.dataset.type;

                            if (!isSequentialElement(targetType)) {
                                propagateToTarget(wire.end, outputValue);
                            }
                        }
                    });
                });
            }

            // 刷新所有组件显示
            function refreshAllComponentDisplays() {
                const allComponents = document.querySelectorAll('.component');
                allComponents.forEach(component => {
                    const componentId = component.dataset.id;
                    const currentState = componentStates.get(componentId);
                    if (currentState !== undefined) {
                        updateComponentDisplay(component, currentState);
                    }
                });
            }

            // 停止时钟信号
            function stopClockSignal(clockComponent) {
                const id = clockComponent.dataset.id;
                if (clockIntervals.has(id)) {
                    clearInterval(clockIntervals.get(id));
                    clockIntervals.delete(id);
                }
            }

            // 设置时钟频率
            function setClockFrequency(clockComponent, frequency) {
                stopClockSignal(clockComponent);
                // 重新启动时钟，但需要修改频率参数
                const id = clockComponent.dataset.id;
                const interval = setInterval(() => {
                    const currentState = componentStates.get(id);
                    const newState = currentState === 0 ? 1 : 0;
                    componentStates.set(id, newState);

                    const bgElement = clockComponent.querySelector('#clock-bg');
                    if (bgElement) {
                        if (newState === 1) {
                            bgElement.classList.add('clock-active');
                        } else {
                            bgElement.classList.remove('clock-active');
                        }
                    }

                    propagateSignal(clockComponent);
                }, frequency);

                clockIntervals.set(id, interval);
            }

            // 删除功能
            // 选择元素
            function selectElement(element) {
                // 清除之前的选择
                if (selectedElement) {
                    selectedElement.classList.remove('selected');
                }

                selectedElement = element;
                element.classList.add('selected');
            }

            // 显示右键菜单
            function showContextMenu(x, y) {
                // 清除之前的动态菜单项
                const dynamicItems = contextMenu.querySelectorAll('.dynamic-item');
                dynamicItems.forEach(item => item.remove());

                // LED灯右键菜单只显示删除选项，配置通过双击打开

                // 如果选中的是按钮，添加配置选项
                if (selectedElement && selectedElement.dataset.type === 'push-button') {
                    const id = selectedElement.dataset.id;
                    const currentConfig = typeof getButtonConfig === 'function' ? getButtonConfig(id) : { trigger: 'high' };

                    const configItem = document.createElement('div');
                    configItem.className = 'context-menu-item dynamic-item';
                    configItem.innerHTML = `<span>触发模式: ${getTriggerModeName(currentConfig.trigger)}</span>`;

                    const subMenu = document.createElement('div');
                    subMenu.className = 'context-submenu';

                    const modes = [
                        { value: 'high', name: '高电平' },
                        { value: 'low', name: '低电平' },
                        { value: 'rising', name: '上升沿' },
                        { value: 'falling', name: '下降沿' }
                    ];

                    modes.forEach(mode => {
                        const subMenuItem = document.createElement('div');
                        subMenuItem.className = 'context-submenu-item';
                        subMenuItem.textContent = mode.name;
                        if (mode.value === currentConfig.trigger) {
                            subMenuItem.classList.add('active');
                        }
                        subMenuItem.addEventListener('click', (e) => {
                            e.stopPropagation();
                            if (typeof setButtonConfig === 'function') {
                                setButtonConfig(id, { trigger: mode.value });
                            }
                            hideContextMenu();
                        });
                        subMenu.appendChild(subMenuItem);
                    });

                    configItem.appendChild(subMenu);
                    contextMenu.appendChild(configItem);
                }

                contextMenu.style.left = x + 'px';
                contextMenu.style.top = y + 'px';
                contextMenu.style.display = 'block';
            }

            // 设置LED颜色
            function setLEDColor(componentId, colorName, colorValue) {
                const component = document.querySelector(`[data-id="${componentId}"]`);
                if (!component) return;

                // 存储LED颜色配置
                if (!component.dataset.ledColor) {
                    component.dataset.ledColor = colorValue;
                }
                component.dataset.ledColor = colorValue;

                // 更新LED显示
                const ledCircle = component.querySelector('circle[fill]');
                if (ledCircle) {
                    // 根据当前状态设置颜色
                    const currentState = componentStates.get(componentId) || 0;
                    if (currentState) {
                        ledCircle.setAttribute('fill', colorValue);
                    } else {
                        // 关闭状态使用暗色
                        ledCircle.setAttribute('fill', '#333333');
                    }
                }
            }

            // 显示LED配置对话框
            function showLEDConfigDialog(component) {
                const id = component.dataset.id;
                const currentColor = component.dataset.ledColor || '#ff0000';

                // 创建对话框
                const dialog = document.createElement('div');
                dialog.className = 'config-dialog led-config-dialog';
                dialog.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: white;
                    border: 2px solid #ccc;
                    border-radius: 8px;
                    padding: 20px;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                    z-index: 10000;
                    min-width: 300px;
                    cursor: move;
                `;

                dialog.innerHTML = `
                    <div class="dialog-header" style="margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee; cursor: move;">
                        <h3 style="margin: 0; color: #333;">LED配置</h3>
                        <button class="close-btn" style="position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 18px; cursor: pointer; color: #999;">&times;</button>
                    </div>
                    <div class="dialog-content">
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 8px; font-weight: bold;">LED颜色:</label>
                            <div class="color-options" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                                <div class="color-option" data-color="#ff0000" style="display: flex; align-items: center; padding: 8px; border: 2px solid transparent; border-radius: 4px; cursor: pointer;">
                                    <div style="width: 20px; height: 20px; background: #ff0000; border-radius: 50%; margin-right: 8px; border: 1px solid #ccc;"></div>
                                    <span>红色</span>
                                </div>
                                <div class="color-option" data-color="#00ff00" style="display: flex; align-items: center; padding: 8px; border: 2px solid transparent; border-radius: 4px; cursor: pointer;">
                                    <div style="width: 20px; height: 20px; background: #00ff00; border-radius: 50%; margin-right: 8px; border: 1px solid #ccc;"></div>
                                    <span>绿色</span>
                                </div>
                                <div class="color-option" data-color="#0000ff" style="display: flex; align-items: center; padding: 8px; border: 2px solid transparent; border-radius: 4px; cursor: pointer;">
                                    <div style="width: 20px; height: 20px; background: #0000ff; border-radius: 50%; margin-right: 8px; border: 1px solid #ccc;"></div>
                                    <span>蓝色</span>
                                </div>
                                <div class="color-option" data-color="#ffff00" style="display: flex; align-items: center; padding: 8px; border: 2px solid transparent; border-radius: 4px; cursor: pointer;">
                                    <div style="width: 20px; height: 20px; background: #ffff00; border-radius: 50%; margin-right: 8px; border: 1px solid #ccc;"></div>
                                    <span>黄色</span>
                                </div>
                                <div class="color-option" data-color="#ff8800" style="display: flex; align-items: center; padding: 8px; border: 2px solid transparent; border-radius: 4px; cursor: pointer;">
                                    <div style="width: 20px; height: 20px; background: #ff8800; border-radius: 50%; margin-right: 8px; border: 1px solid #ccc;"></div>
                                    <span>橙色</span>
                                </div>
                                <div class="color-option" data-color="#ffffff" style="display: flex; align-items: center; padding: 8px; border: 2px solid transparent; border-radius: 4px; cursor: pointer;">
                                    <div style="width: 20px; height: 20px; background: #ffffff; border-radius: 50%; margin-right: 8px; border: 1px solid #333;"></div>
                                    <span>白色</span>
                                </div>
                            </div>
                        </div>
                        <div style="text-align: right; margin-top: 20px;">
                            <button class="cancel-btn" style="margin-right: 10px; padding: 8px 16px; border: 1px solid #ccc; background: white; border-radius: 4px; cursor: pointer;">取消</button>
                            <button class="apply-btn" style="padding: 8px 16px; border: none; background: #007bff; color: white; border-radius: 4px; cursor: pointer;">应用</button>
                        </div>
                    </div>
                `;

                // 设置当前选中的颜色
                const colorOptions = dialog.querySelectorAll('.color-option');
                colorOptions.forEach(option => {
                    if (option.dataset.color === currentColor) {
                        option.style.border = '2px solid #007bff';
                        option.style.backgroundColor = '#f0f8ff';
                    }

                    option.addEventListener('click', function() {
                        // 清除其他选项的选中状态
                        colorOptions.forEach(opt => {
                            opt.style.border = '2px solid transparent';
                            opt.style.backgroundColor = 'transparent';
                        });
                        // 设置当前选项为选中状态
                        this.style.border = '2px solid #007bff';
                        this.style.backgroundColor = '#f0f8ff';
                    });
                });

                // 添加到页面
                document.body.appendChild(dialog);

                // 使对话框可拖动
                makeDraggable(dialog);

                // 事件处理
                const closeBtn = dialog.querySelector('.close-btn');
                const cancelBtn = dialog.querySelector('.cancel-btn');
                const applyBtn = dialog.querySelector('.apply-btn');

                closeBtn.addEventListener('click', () => {
                    document.body.removeChild(dialog);
                });

                cancelBtn.addEventListener('click', () => {
                    document.body.removeChild(dialog);
                });

                applyBtn.addEventListener('click', () => {
                    const selectedOption = dialog.querySelector('.color-option[style*="border: 2px solid rgb(0, 123, 255)"]');
                    if (selectedOption) {
                        const newColor = selectedOption.dataset.color;
                        setLEDColor(id, getColorName(newColor), newColor);
                    }
                    document.body.removeChild(dialog);
                });

                // 点击对话框外部关闭
                setTimeout(() => {
                    document.addEventListener('click', function closeDialog(e) {
                        if (!dialog.contains(e.target)) {
                            if (document.body.contains(dialog)) {
                                document.body.removeChild(dialog);
                            }
                            document.removeEventListener('click', closeDialog);
                        }
                    });
                }, 100);
            }

            // 获取颜色名称
            function getColorName(color) {
                const colorNames = {
                    '#ff0000': '红色',
                    '#00ff00': '绿色',
                    '#0000ff': '蓝色',
                    '#ffff00': '黄色',
                    '#ff8800': '橙色',
                    '#ffffff': '白色'
                };
                return colorNames[color] || '红色';
            }

            // 使元素可拖动
            function makeDraggable(element) {
                let isDragging = false;
                let startX, startY, startLeft, startTop;

                const header = element.querySelector('.dialog-header');

                header.addEventListener('mousedown', function(e) {
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;

                    const rect = element.getBoundingClientRect();
                    startLeft = rect.left;
                    startTop = rect.top;

                    element.style.transform = 'none';
                    element.style.left = startLeft + 'px';
                    element.style.top = startTop + 'px';

                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);

                    e.preventDefault();
                });

                function onMouseMove(e) {
                    if (!isDragging) return;

                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;

                    element.style.left = (startLeft + deltaX) + 'px';
                    element.style.top = (startTop + deltaY) + 'px';
                }

                function onMouseUp() {
                    isDragging = false;
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                }
            }

            // 更新LED显示
            function updateLEDDisplay(component, state) {
                const componentId = component.dataset.id;
                const customColor = component.dataset.ledColor || '#ff0000'; // 默认红色

                // 查找LED的圆形元素 - 尝试多种选择器
                let ledCircle = component.querySelector('circle[fill]');
                if (!ledCircle) {
                    ledCircle = component.querySelector('circle');
                }
                if (!ledCircle) {
                    ledCircle = component.querySelector('#led-body');
                }

                if (ledCircle) {
                    if (state) {
                        // 亮起状态：使用自定义颜色
                        ledCircle.setAttribute('fill', customColor);
                        ledCircle.setAttribute('stroke', customColor);
                        ledCircle.setAttribute('stroke-width', '2');
                        // 添加发光效果
                        ledCircle.style.filter = 'drop-shadow(0 0 6px ' + customColor + ')';
                    } else {
                        // 关闭状态：使用暗色
                        ledCircle.setAttribute('fill', '#333333');
                        ledCircle.setAttribute('stroke', '#666666');
                        ledCircle.setAttribute('stroke-width', '1');
                        ledCircle.style.filter = 'none';
                    }
                }

                // 更新组件背景色以反映状态
                const rect = component.querySelector('rect');
                if (rect) {
                    rect.setAttribute('fill', state ? '#f0f8f0' : '#f8f0f0');
                }
            }

            // 获取触发模式的中文名称
            function getTriggerModeName(trigger) {
                const names = {
                    'high': '高电平',
                    'low': '低电平',
                    'rising': '上升沿',
                    'falling': '下降沿'
                };
                return names[trigger] || '高电平';
            }

            // 显示输入端口配置对话框
            function showInputPortConfigDialog(component) {
                const id = component.dataset.id;
                const currentBitWidth = getComponentBitWidth(id);
                const currentData = getComponentMultiBitData(id);
                const currentBinary = getComponentBinaryString(id);
                
                const dialog = document.createElement('div');
                dialog.className = 'config-dialog';
                dialog.innerHTML = `
                    <div class="config-dialog-content">
                        <h3>📥 输入端口配置</h3>
                        <div class="config-group">
                            <label>位宽设置:</label>
                            <select id="input-bitwidth-select">
                                <option value="1" ${currentBitWidth === 1 ? 'selected' : ''}>单位 (1bit)</option>
                                <option value="2" ${currentBitWidth === 2 ? 'selected' : ''}>双位 (2bit)</option>
                                <option value="4" ${currentBitWidth === 4 ? 'selected' : ''}>四位 (4bit)</option>
                                <option value="8" ${currentBitWidth === 8 ? 'selected' : ''}>字节 (8bit)</option>
                                <option value="16" ${currentBitWidth === 16 ? 'selected' : ''}>字 (16bit)</option>
                                <option value="32" ${currentBitWidth === 32 ? 'selected' : ''}>双字 (32bit)</option>
                                <option value="custom">自定义...</option>
                            </select>
                            <input type="number" id="custom-bitwidth" min="1" max="64" value="${currentBitWidth}" style="display:none; width:60px; margin-left:10px;">
                        </div>
                        
                        <div class="config-group">
                            <label>当前值:</label>
                            <div style="background: #f0f0f0; padding: 8px; border-radius: 4px; margin: 5px 0; font-family: monospace;">
                                二进制: ${currentBinary}
                            </div>
                        </div>
                        
                        <div class="config-group">
                            <label>输入新值（二进制）:</label><br>
                            <input type="text" id="dataInput" placeholder="请输入二进制数值，如: 101" style="width: 100%; margin-top: 8px; padding: 6px;">
                        </div>
                        
                        <div class="config-group" id="bit-controls-group">
                            <label>按位设置:</label><br>
                            <div id="bitControls" style="margin-top: 8px;"></div>
                        </div>
                        
                        <div class="config-buttons">
                            <button onclick="applyInputPortConfig(this)">确定</button>
                            <button onclick="cancelInputPortConfig(this)">取消</button>
                        </div>
                    </div>
                `;
                
                dialog.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    width: auto;
                    height: auto;
                    background: none;
                    display: block;
                    z-index: 10000;
                `;
                
                dialog.querySelector('.config-dialog-content').style.cssText = `
                    background: white;
                    padding: 20px;
                    border-radius: 12px;
                    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                    min-width: 400px;
                    max-width: 500px;
                `;
                
                dialog.dataset.componentId = id;
                document.body.appendChild(dialog);
                
                // 生成按位控制按钮
                updateBitControls(dialog);
                
                // 监听位宽变化
                dialog.querySelector('#input-bitwidth-select').addEventListener('change', function() {
                    const customInput = dialog.querySelector('#custom-bitwidth');
                    if (this.value === 'custom') {
                        customInput.style.display = 'inline';
                        customInput.focus();
                    } else {
                        customInput.style.display = 'none';
                        updateBitControls(dialog);
                    }
                });
                
                // 监听自定义位宽输入
                dialog.querySelector('#custom-bitwidth').addEventListener('input', function() {
                    updateBitControls(dialog);
                });
            }

            // 显示输出端口配置对话框
            function showOutputPortConfigDialog(component) {
                const id = component.dataset.id;
                const currentBitWidth = getComponentBitWidth(id);
                const currentData = getComponentMultiBitData(id);
                const currentBinary = getComponentBinaryString(id);

                const dialog = document.createElement('div');
                dialog.className = 'config-dialog';
                dialog.innerHTML = `
                    <div class="config-dialog-content">
                        <h3>📤 输出端口配置</h3>
                        <div class="config-group">
                            <label>位宽设置:</label>
                            <select id="output-bitwidth-select">
                                <option value="1" ${currentBitWidth === 1 ? 'selected' : ''}>单位 (1bit)</option>
                                <option value="2" ${currentBitWidth === 2 ? 'selected' : ''}>双位 (2bit)</option>
                                <option value="4" ${currentBitWidth === 4 ? 'selected' : ''}>四位 (4bit)</option>
                                <option value="8" ${currentBitWidth === 8 ? 'selected' : ''}>字节 (8bit)</option>
                                <option value="16" ${currentBitWidth === 16 ? 'selected' : ''}>字 (16bit)</option>
                                <option value="32" ${currentBitWidth === 32 ? 'selected' : ''}>双字 (32bit)</option>
                                <option value="custom">自定义...</option>
                            </select>
                            <input type="number" id="output-custom-bitwidth" min="1" max="64" value="${currentBitWidth}" style="display:none; width:60px; margin-left:10px;">
                        </div>

                        <div class="config-group">
                            <label>当前接收值:</label>
                            <div style="background: #f0f0f0; padding: 8px; border-radius: 4px; margin: 5px 0; font-family: monospace;">
                                二进制: ${currentBinary}
                            </div>
                            <div style="background: #e8f4fd; padding: 8px; border-radius: 4px; margin: 5px 0; font-size: 12px; color: #666;">
                                💡 输出端口的值由连接的输入信号决定，无法手动设置
                            </div>
                        </div>

                        <div class="config-group">
                            <label>位宽说明:</label>
                            <div style="background: #f8f9fa; padding: 8px; border-radius: 4px; margin: 5px 0; font-size: 12px; color: #666;">
                                • 位宽决定了输出端口能接收的数据位数<br>
                                • 当输入信号位宽与输出端口位宽不匹配时：<br>
                                &nbsp;&nbsp;- 输入位宽 > 输出位宽：截取低位<br>
                                &nbsp;&nbsp;- 输入位宽 < 输出位宽：高位补0
                            </div>
                        </div>

                        <div class="config-buttons">
                            <button onclick="applyOutputPortConfig(this)">确定</button>
                            <button onclick="cancelOutputPortConfig(this)">取消</button>
                        </div>
                    </div>
                `;

                dialog.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    width: auto;
                    height: auto;
                    background: none;
                    display: block;
                    z-index: 10000;
                `;

                dialog.querySelector('.config-dialog-content').style.cssText = `
                    background: white;
                    padding: 20px;
                    border-radius: 12px;
                    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                    min-width: 400px;
                    max-width: 500px;
                `;

                dialog.dataset.componentId = id;
                document.body.appendChild(dialog);

                // 监听位宽变化
                dialog.querySelector('#output-bitwidth-select').addEventListener('change', function() {
                    const customInput = dialog.querySelector('#output-custom-bitwidth');
                    if (this.value === 'custom') {
                        customInput.style.display = 'inline';
                        customInput.focus();
                    } else {
                        customInput.style.display = 'none';
                    }
                });
            }

            // 隐藏右键菜单
            function hideContextMenu() {
                contextMenu.style.display = 'none';
            }

            // 删除选中的元素
            function deleteSelectedElement() {
                if (!selectedElement) return;



                if (selectedElement.classList.contains('component')) {
                    deleteComponent(selectedElement);
                } else if (selectedElement.classList.contains('wire')) {
                    deleteWire(selectedElement);
                } else if (selectedElement.classList.contains('text-element')) {
                    deleteTextElement(selectedElement);
                }

                selectedElement = null;
                hideContextMenu();
            }

            // 删除文字元素
            function deleteTextElement(textElement) {
                if (textElement && textElement.parentNode) {
                    textElement.parentNode.removeChild(textElement);
                }
            }

            // 删除元件
            function deleteComponent(component) {
                const id = component.dataset.id;
                const type = component.dataset.type;

                // 停止时钟信号（如果是时钟元件）
                if (type === 'clock') {
                    stopClockSignal(component);
                }

                // 删除与该元件相关的所有连线
                const relatedWires = [];
                wires.forEach((wire, index) => {
                    if ((wire.start && wire.start.closest('.component') === component) ||
                        (wire.end && wire.end.closest('.component') === component)) {
                        relatedWires.push(index);
                    }
                });

                // 从后往前删除，避免索引问题
                relatedWires.reverse().forEach(index => {
                    const wire = wires[index];
                    // 删除锚点连接关系 - 支持多个连接
                    if (wire.start && wire.end) {
                        // 从起始锚点的连接列表中移除目标锚点
                        if (anchorConnections.has(wire.start)) {
                            const startConnections = anchorConnections.get(wire.start);
                            const targetIndex = startConnections.indexOf(wire.end);
                            if (targetIndex > -1) {
                                startConnections.splice(targetIndex, 1);
                            }
                            // 如果连接列表为空，删除整个条目
                            if (startConnections.length === 0) {
                                anchorConnections.delete(wire.start);
                            }
                        }

                        // 从目标锚点的连接列表中移除起始锚点
                        if (anchorConnections.has(wire.end)) {
                            const endConnections = anchorConnections.get(wire.end);
                            const startIndex = endConnections.indexOf(wire.start);
                            if (startIndex > -1) {
                                endConnections.splice(startIndex, 1);
                            }
                            // 如果连接列表为空，删除整个条目
                            if (endConnections.length === 0) {
                                anchorConnections.delete(wire.end);
                            }
                        }
                    }
                    // 删除连线元素
                    if (wire.line.parentNode) {
                        wire.line.parentNode.removeChild(wire.line);
                    }
                    // 从数组中删除
                    wires.splice(index, 1);
                });

                // 删除元件状态
                componentStates.delete(id);

                // 删除元件DOM元素
                if (component.parentNode) {
                    component.parentNode.removeChild(component);
                }


            }

            // 删除连线
            function deleteWire(wireElement) {
                const wireIndex = wires.findIndex(wire => wire.line === wireElement);
                if (wireIndex === -1) return;

                const wire = wires[wireIndex];

                // 删除锚点连接关系 - 支持多个连接
                if (wire.start && wire.end) {
                    // 从起始锚点的连接列表中移除目标锚点
                    if (anchorConnections.has(wire.start)) {
                        const startConnections = anchorConnections.get(wire.start);
                        const targetIndex = startConnections.indexOf(wire.end);
                        if (targetIndex > -1) {
                            startConnections.splice(targetIndex, 1);
                        }
                        // 如果连接列表为空，删除整个条目
                        if (startConnections.length === 0) {
                            anchorConnections.delete(wire.start);
                        }
                    }

                    // 从目标锚点的连接列表中移除起始锚点
                    if (anchorConnections.has(wire.end)) {
                        const endConnections = anchorConnections.get(wire.end);
                        const startIndex = endConnections.indexOf(wire.start);
                        if (startIndex > -1) {
                            endConnections.splice(startIndex, 1);
                        }
                        // 如果连接列表为空，删除整个条目
                        if (endConnections.length === 0) {
                            anchorConnections.delete(wire.end);
                        }
                    }
                }

                // 删除所有以此连线为分支源的分支连线
                const branchWires = wires.filter(w => w.branchFrom === wireElement);
                branchWires.forEach(branchWire => {
                    if (branchWire.line.parentNode) {
                        branchWire.line.parentNode.removeChild(branchWire.line);
                    }
                });

                // 删除所有连接到此连线的连线
                const connectingWires = wires.filter(w => w.connectsTo === wireElement);
                connectingWires.forEach(connectingWire => {
                    if (connectingWire.line.parentNode) {
                        connectingWire.line.parentNode.removeChild(connectingWire.line);
                    }
                });

                // 从数组中删除所有相关连线
                for (let i = wires.length - 1; i >= 0; i--) {
                    const w = wires[i];
                    if (w.line === wireElement || w.branchFrom === wireElement || w.connectsTo === wireElement) {
                        wires.splice(i, 1);
                    }
                }

                // 删除连线DOM元素
                if (wireElement.parentNode) {
                    wireElement.parentNode.removeChild(wireElement);
                }


            }

            // 事件监听器
            // 点击空白区域取消选择
            canvas.addEventListener('click', function (e) {
                if (e.target === canvas || e.target === wireLayer) {
                    if (selectedElement) {
                        selectedElement.classList.remove('selected');
                        selectedElement = null;
                    }
                    hideContextMenu();
                }
            });

            // 点击其他地方隐藏右键菜单
            document.addEventListener('click', function (e) {
                if (!contextMenu.contains(e.target)) {
                    hideContextMenu();
                }
            });

            // 右键菜单项点击事件
            deleteItem.addEventListener('click', function () {
                deleteSelectedElement();
            });

            // 键盘控制功能
            document.addEventListener('keydown', function (e) {
                // 如果正在输入，不处理快捷键
                if (document.activeElement.tagName === 'INPUT' ||
                    document.activeElement.tagName === 'TEXTAREA' ||
                    document.activeElement.contentEditable === 'true') {
                    return;
                }

                // 复制粘贴快捷键
                if (e.ctrlKey || e.metaKey) {
                    switch(e.key.toLowerCase()) {
                        case 'c':
                            e.preventDefault();
                            if (typeof copySelectedComponents === 'function') {
                                copySelectedComponents();
                            }
                            return;
                        case 'v':
                            e.preventDefault();
                            if (typeof pasteComponents === 'function') {
                                pasteComponents();
                            }
                            return;
                        case 'x':
                            e.preventDefault();
                            if (typeof cutSelectedComponents === 'function') {
                                cutSelectedComponents();
                            }
                            return;
                        case 'a':
                            e.preventDefault();
                            if (typeof selectAllComponents === 'function') {
                                selectAllComponents();
                            }
                            return;
                    }
                }

                // 删除功能
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    e.preventDefault();
                    // 优先使用复制粘贴系统的删除功能
                    if (typeof deleteSelectedComponents === 'function' && selectedComponents && selectedComponents.size > 0) {
                        deleteSelectedComponents();
                    } else if (selectedElement) {
                        deleteSelectedElement();
                    }
                    return;
                }

                // 旋转功能 - 处理方向键
                if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
                    // 优先使用选中的组件，其次使用鼠标下的组件
                    const targetComponent = selectedElement || hoveredComponent;

                    if (targetComponent && targetComponent.classList.contains('component')) {
                        const svg = targetComponent.querySelector('svg');
                        if (!svg) return;

                        let rotation = 0;
                        const scale = parseFloat(targetComponent.dataset.scale) || 1;

                        // 根据按键方向设置旋转角度
                        if (e.key === 'ArrowUp') {
                            rotation = 270;  // 朝向上
                        } else if (e.key === 'ArrowDown') {
                            rotation = 90;  // 朝向下
                        } else if (e.key === 'ArrowRight') {
                            rotation = 0;  // 朝向右
                        } else if (e.key === 'ArrowLeft') {
                            rotation = 180;  // 朝向左
                        }

                        e.preventDefault();
                        targetComponent.dataset.rotation = rotation;
                        svg.style.transform = `rotate(${rotation}deg) scale(${scale})`;

                        // 更新所有连线位置
                        wires.forEach(wire => {
                            if (wire.start && wire.start.closest('.component') === targetComponent ||
                                wire.end && wire.end.closest('.component') === targetComponent) {
                                updateWirePosition(wire);
                            }
                        });
                    }
                }
            });

            // 画布点击事件 - 处理文字工具和取消选择
            canvas.addEventListener('click', function(e) {
                if (currentTool === 'text') {
                    // 确保点击的是画布空白区域，不是元件或连线
                    if (e.target === canvas || e.target.id === 'circuit-canvas') {
                        const canvasRect = canvas.getBoundingClientRect();
                        const x = e.clientX - canvasRect.left;
                        const y = e.clientY - canvasRect.top;

                        createTextElement(x, y);

                        // 重置工具状态
                        toolbarItems.forEach(t => t.classList.remove('active'));
                        currentTool = null;
                        canvas.style.cursor = 'default';
                    }
                } else {
                    // 点击空白区域取消选择
                    if (e.target === canvas || e.target.id === 'circuit-canvas') {
                        if (selectedElement) {
                            selectedElement.classList.remove('selected');
                            selectedElement = null;
                        }
                        // 取消工具选择
                        if (currentTool) {
                            toolbarItems.forEach(t => t.classList.remove('active'));
                            currentTool = null;
                            canvas.style.cursor = 'default';
                        }
                    }
                }
            });

            // 创建文字元素的函数
            function createTextElement(x, y) {
                const textDiv = document.createElement('div');
                textDiv.className = 'text-element';
                textDiv.style.position = 'absolute';
                textDiv.style.left = x + 'px';
                textDiv.style.top = y + 'px';
                textDiv.style.fontSize = '14px';
                textDiv.style.fontFamily = 'Arial, sans-serif';
                textDiv.style.color = '#000';
                textDiv.style.background = 'rgba(255, 255, 255, 0.8)';
                textDiv.style.padding = '2px 4px';
                textDiv.style.border = '1px dashed #ccc';
                textDiv.style.borderRadius = '3px';
                textDiv.style.cursor = 'move';
                textDiv.style.minWidth = '20px'; // 减小最小宽度
                textDiv.style.width = 'auto'; // 自动宽度
                textDiv.style.display = 'inline-block'; // 使用inline-block以适应内容
                textDiv.style.whiteSpace = 'nowrap'; // 防止换行
                textDiv.style.zIndex = '15';
                textDiv.contentEditable = true;
                textDiv.textContent = '文字';

                canvas.appendChild(textDiv);

                // 初始调整大小
                adjustTextElementSize(textDiv);

                // 自动选中文字进行编辑
                textDiv.focus();
                // 选中所有文字内容
                setTimeout(() => {
                    const range = document.createRange();
                    range.selectNodeContents(textDiv);
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                }, 0);

                // 添加文字元素的事件监听器
                addTextElementEventListeners(textDiv);
            }

            // 调整文字元素大小以适应内容
            function adjustTextElementSize(textDiv) {
                // 创建一个临时的测量元素
                const measurer = document.createElement('div');
                measurer.style.position = 'absolute';
                measurer.style.visibility = 'hidden';
                measurer.style.whiteSpace = 'nowrap';
                measurer.style.fontSize = textDiv.style.fontSize;
                measurer.style.fontFamily = textDiv.style.fontFamily;
                measurer.style.padding = textDiv.style.padding;
                measurer.textContent = textDiv.textContent || '文字';

                document.body.appendChild(measurer);

                // 获取实际需要的宽度
                const contentWidth = measurer.offsetWidth;

                // 设置最小宽度为20px，实际宽度为内容宽度
                const finalWidth = Math.max(20, contentWidth);
                textDiv.style.width = finalWidth + 'px';

                // 清理临时元素
                document.body.removeChild(measurer);
            }

            // 添加文字元素事件监听器
            function addTextElementEventListeners(textDiv) {
                let isDragging = false;
                let startX, startY;
                let startLeft, startTop;

                // 鼠标按下事件
                textDiv.addEventListener('mousedown', function(e) {
                    // 只有在非编辑状态下才能拖动
                    if (!textDiv.matches(':focus')) {
                        isDragging = true;
                        startX = e.clientX;
                        startY = e.clientY;
                        startLeft = parseInt(textDiv.style.left) || 0;
                        startTop = parseInt(textDiv.style.top) || 0;
                        textDiv.style.cursor = 'grabbing';
                        e.preventDefault();
                        e.stopPropagation();

                        // 选择文字元素
                        selectElement(textDiv);
                    }
                });

                // 鼠标移动事件
                document.addEventListener('mousemove', function(e) {
                    if (!isDragging) return;

                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;

                    let newLeft = startLeft + deltaX;
                    let newTop = startTop + deltaY;

                    // 限制在画布内
                    const canvasRect = canvas.getBoundingClientRect();
                    newLeft = Math.max(0, Math.min(newLeft, canvasRect.width - textDiv.offsetWidth));
                    newTop = Math.max(0, Math.min(newTop, canvasRect.height - textDiv.offsetHeight));

                    textDiv.style.left = newLeft + 'px';
                    textDiv.style.top = newTop + 'px';
                });

                // 鼠标释放事件
                document.addEventListener('mouseup', function() {
                    if (isDragging) {
                        isDragging = false;
                        textDiv.style.cursor = 'move';
                    }
                });

                // 右键菜单
                textDiv.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    selectElement(textDiv);
                    showContextMenu(e.clientX, e.clientY);
                });

                // 点击选择和编辑
                textDiv.addEventListener('click', function(e) {
                    e.stopPropagation();
                    selectElement(textDiv);

                    // 双击进入编辑模式
                    if (e.detail === 2) {
                        textDiv.focus();
                        // 选中所有文字
                        setTimeout(() => {
                            const range = document.createRange();
                            range.selectNodeContents(textDiv);
                            const selection = window.getSelection();
                            selection.removeAllRanges();
                            selection.addRange(range);
                        }, 0);
                    }
                });

                // 编辑完成时的处理
                textDiv.addEventListener('blur', function() {
                    if (textDiv.textContent.trim() === '') {
                        textDiv.textContent = '文字';
                    }
                    // 编辑完成后调整大小
                    adjustTextElementSize(textDiv);
                });

                // 输入事件 - 实时调整大小
                textDiv.addEventListener('input', function() {
                    adjustTextElementSize(textDiv);
                });

                // 按键处理
                textDiv.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        textDiv.blur(); // 完成编辑
                        e.preventDefault();
                    } else if (e.key === 'Escape') {
                        textDiv.blur(); // 取消编辑
                        e.preventDefault();
                    }
                    e.stopPropagation(); // 防止触发全局按键事件
                });

                // 按键释放后也调整大小（处理删除等操作）
                textDiv.addEventListener('keyup', function(e) {
                    // 延迟调整，确保内容已更新
                    setTimeout(() => {
                        adjustTextElementSize(textDiv);
                    }, 0);
                });
            }



            // 阻止浏览器默认右键菜单  第二版
            canvas.addEventListener('contextmenu', function (e) {
                e.preventDefault();
            });

            // 输入端口配置对话框支持函数
            // 更新按位控制按钮
            function updateBitControls(dialog) {
                const bitWidthSelect = dialog.querySelector('#input-bitwidth-select');
                const customInput = dialog.querySelector('#custom-bitwidth');
                const componentId = dialog.dataset.componentId;
                
                let bitWidth;
                if (bitWidthSelect.value === 'custom') {
                    bitWidth = parseInt(customInput.value) || 1;
                } else {
                    bitWidth = parseInt(bitWidthSelect.value);
                }
                
                const currentData = getComponentMultiBitData(componentId);
                const bitControls = dialog.querySelector('#bitControls');
                bitControls.innerHTML = '';
                
                for (let i = 0; i < bitWidth; i++) {
                    const bitValue = i < currentData.length ? currentData[i] : 0;
                    const button = document.createElement('button');
                    button.textContent = `Bit${bitWidth-1-i}: ${bitValue}`;
                    button.style.cssText = `
                        margin: 2px;
                        padding: 6px 12px;
                        background: ${bitValue ? '#4CAF50' : '#f44336'};
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                        font-size: 12px;
                    `;
                    button.onclick = () => toggleBitInDialog(dialog, i);
                    bitControls.appendChild(button);
                    
                    // 每8个按钮换一行
                    if ((i + 1) % 8 === 0) {
                        bitControls.appendChild(document.createElement('br'));
                    }
                }
            }
            
            // 在对话框中切换某一位的值
            function toggleBitInDialog(dialog, bitIndex) {
                const componentId = dialog.dataset.componentId;
                const data = getComponentMultiBitData(componentId);
                const newValue = (data[bitIndex] || 0) === 0 ? 1 : 0;
                
                // 更新数据
                const newData = [...data];
                newData[bitIndex] = newValue;
                setComponentMultiBitData(componentId, newData);
                
                // 更新按钮显示
                updateBitControls(dialog);
                
                // 更新当前值显示
                updateCurrentValueDisplay(dialog);
                
                // 更新组件显示
                updatePortDisplay(componentId);
                
                // 传播信号
                const component = document.querySelector(`[data-id="${componentId}"]`);
                if (component) {
                    propagateSignal(component);
                }
            }
            
            // 更新当前值显示
            function updateCurrentValueDisplay(dialog) {
                const componentId = dialog.dataset.componentId;
                const currentBinary = getComponentBinaryString(componentId);
                
                const valueDisplay = dialog.querySelector('.config-group div[style*="background: #f0f0f0"]');
                if (valueDisplay) {
                    valueDisplay.innerHTML = `二进制: ${currentBinary}`;
                }
            }

            // 将必要的函数暴露到全局作用域
            window.setComponentBitWidth = setComponentBitWidth;
            window.getComponentBitWidth = getComponentBitWidth;
            window.setComponentMultiBitData = setComponentMultiBitData;
            window.getComponentMultiBitData = getComponentMultiBitData;
            window.setComponentBitData = setComponentBitData;
            window.updatePortDisplay = updatePortDisplay;
            window.propagateSignal = propagateSignal;
            window.getComponentBinaryString = getComponentBinaryString;
            window.showInputPortConfigDialog = showInputPortConfigDialog;
            window.showOutputPortConfigDialog = showOutputPortConfigDialog;

            // 暴露组件初始化函数供复制粘贴系统使用
            window.initializeComponent = initializeComponent;
            window.addComponentEventListeners = addComponentEventListeners;

            // ==================== 复制粘贴系统 ====================
            let clipboard = [];
            let selectedComponents = new Set();
            let lastMouseX = 0, lastMouseY = 0;

            // 跟踪鼠标位置
            document.addEventListener('mousemove', (e) => {
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });



            // 组件选择 - 不显示选中框，只保留选中逻辑
            document.addEventListener('click', (e) => {
                const component = e.target.closest('.component');

                if (component) {
                    if (e.ctrlKey || e.metaKey) {
                        // Ctrl+点击：切换选中
                        if (selectedComponents.has(component)) {
                            selectedComponents.delete(component);
                            component.dataset.selected = 'false';
                        } else {
                            selectedComponents.add(component);
                            component.dataset.selected = 'true';
                        }
                    } else {
                        // 普通点击：单选
                        selectedComponents.clear();
                        selectedComponents.add(component);
                        component.dataset.selected = 'true';
                    }
                } else {
                    // 点击空白：清除选中
                    selectedComponents.forEach(comp => {
                        comp.dataset.selected = 'false';
                    });
                    selectedComponents.clear();
                }
            });

            // 全选
            function selectAllComponents() {
                selectedComponents.forEach(comp => {
                    comp.dataset.selected = 'false';
                });
                selectedComponents.clear();

                const components = document.querySelectorAll('.component');
                components.forEach(comp => {
                    selectedComponents.add(comp);
                    comp.dataset.selected = 'true';
                });
                showToast(`已选择 ${components.length} 个组件`);
            }

            // 复制组件
            function copySelectedComponents() {
                if (selectedComponents.size === 0) {
                    showToast('请先选择要复制的组件', 'warning');
                    return;
                }

                clipboard = [];
                selectedComponents.forEach(component => {
                    const componentData = captureComponentData(component);
                    clipboard.push(componentData);
                });

                showToast(`已复制 ${clipboard.length} 个组件`);
            }

            // 捕获组件完整数据
            function captureComponentData(component) {
                const id = component.dataset.id;
                const type = component.dataset.type;

                return {
                    html: component.outerHTML,
                    type: type,
                    originalId: id,
                    // 保存组件状态
                    state: componentStates.get(id) || 0,
                    multiBitData: [...(componentMultiBitData.get(id) || [0])],
                    // 保存位宽信息
                    bitWidth: getComponentBitWidth(id),
                    // 保存其他属性
                    pinMode: component.dataset.pinMode,
                    triState: component.dataset.triState,
                    pinValue: component.dataset.pinValue,
                    // 保存位置信息
                    position: {
                        left: component.style.left,
                        top: component.style.top,
                        transform: component.style.transform
                    }
                };
            }

            // 粘贴组件
            function pasteComponents() {
                if (clipboard.length === 0) {
                    showToast('剪贴板为空', 'warning');
                    return;
                }

                const canvas = document.getElementById('circuit-canvas');
                const canvasRect = canvas.getBoundingClientRect();

                // 计算粘贴位置（跟随鼠标）
                let pasteX = lastMouseX - canvasRect.left;
                let pasteY = lastMouseY - canvasRect.top;

                // 确保在画布内
                pasteX = Math.max(20, Math.min(pasteX, canvasRect.width - 150));
                pasteY = Math.max(20, Math.min(pasteY, canvasRect.height - 100));

                // 清除之前的选中
                selectedComponents.forEach(comp => {
                    comp.dataset.selected = 'false';
                });
                selectedComponents.clear();

                clipboard.forEach((data, index) => {
                    const newComponent = createComponentFromData(data, pasteX + index * 30, pasteY + index * 30);
                    canvas.appendChild(newComponent);
                    selectedComponents.add(newComponent);
                    newComponent.dataset.selected = 'true';
                });

                showToast(`已粘贴 ${clipboard.length} 个组件`);
            }

            // 从数据创建组件
            function createComponentFromData(data, x, y) {
                // 解析HTML
                const temp = document.createElement('div');
                temp.innerHTML = data.html;
                const newComponent = temp.firstElementChild;

                // 生成新的唯一ID
                const newId = Date.now() + '_' + Math.random().toString(36).substr(2, 6);
                newComponent.id = newId;
                newComponent.dataset.id = newId;

                // 设置位置
                newComponent.style.left = x + 'px';
                newComponent.style.top = y + 'px';
                newComponent.style.position = 'absolute';

                // 恢复其他属性
                if (data.pinMode) newComponent.dataset.pinMode = data.pinMode;
                if (data.triState) newComponent.dataset.triState = data.triState;
                if (data.pinValue) newComponent.dataset.pinValue = data.pinValue;

                // 初始化组件状态
                componentStates.set(newId, data.state);
                componentMultiBitData.set(newId, [...data.multiBitData]);

                // 设置位宽
                if (data.bitWidth > 1) {
                    componentBitWidths.set(newId, data.bitWidth);
                }

                // 使用主项目的初始化函数完整初始化组件
                initializeComponent(newComponent, data.type);



                return newComponent;
            }

            // 剪切组件
            function cutSelectedComponents() {
                if (selectedComponents.size === 0) {
                    showToast('请先选择要剪切的组件', 'warning');
                    return;
                }

                copySelectedComponents();
                deleteSelectedComponents();
                showToast('已剪切组件');
            }

            // 删除组件
            function deleteSelectedComponents() {
                if (selectedComponents.size === 0) {
                    showToast('请先选择要删除的组件', 'warning');
                    return;
                }

                const count = selectedComponents.size;

                selectedComponents.forEach(component => {
                    const id = component.dataset.id;

                    // 清理状态数据
                    componentStates.delete(id);
                    componentMultiBitData.delete(id);
                    componentBitWidths.delete(id);

                    // 移除DOM元素
                    component.remove();
                });

                // 清除选中
                selectedComponents.clear();
                showToast(`已删除 ${count} 个组件`);
            }

            // 显示提示消息
            function showToast(message, type = 'success') {
                const toast = document.createElement('div');
                toast.textContent = message;
                toast.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 12px 20px;
                    border-radius: 6px;
                    color: white;
                    font-size: 14px;
                    z-index: 10000;
                    background: ${type === 'warning' ? '#ff9800' : '#4caf50'};
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    transition: all 0.3s ease;
                `;

                document.body.appendChild(toast);

                // 动画效果
                setTimeout(() => {
                    toast.style.transform = 'translateX(0)';
                    toast.style.opacity = '1';
                }, 10);

                setTimeout(() => {
                    toast.style.transform = 'translateX(100%)';
                    toast.style.opacity = '0';
                    setTimeout(() => toast.remove(), 300);
                }, 3000);
            }

            // 绑定菜单项
            setTimeout(() => {
                const menuItems = document.querySelectorAll('a, button');
                menuItems.forEach(item => {
                    const text = item.textContent.trim();
                    if (text.includes('复制')) {
                        item.addEventListener('click', (e) => {
                            e.preventDefault();
                            copySelectedComponents();
                        });
                    }
                    if (text.includes('粘贴')) {
                        item.addEventListener('click', (e) => {
                            e.preventDefault();
                            pasteComponents();
                        });
                    }
                });
            }, 1000);

            // LED逻辑测试函数
            window.testLEDLogic = function() {
                const leds = document.querySelectorAll('[data-type="led-diode"]');
                if (leds.length === 0) {
                    return false;
                }

                leds.forEach((led, index) => {
                    const id = led.dataset.id;

                    // 测试输入0（应该熄灭）
                    componentStates.set(id, 0);
                    updateLEDDisplay(led, 0);

                    setTimeout(() => {
                        // 测试输入1（应该点亮）
                        componentStates.set(id, 1);
                        updateLEDDisplay(led, 1);

                        setTimeout(() => {
                            // 恢复为0
                            componentStates.set(id, 0);
                            updateLEDDisplay(led, 0);
                        }, 1000);
                    }, 1000);
                });

                return true;
            };

            // LED连接测试函数
            window.testLEDConnection = function() {
                const inputs = document.querySelectorAll('[data-type="input"]');
                const leds = document.querySelectorAll('[data-type="led-diode"]');

                if (inputs.length === 0 || leds.length === 0) {
                    return false;
                }

                const input = inputs[0];
                const led = leds[0];
                const inputId = input.dataset.id;
                const ledId = led.dataset.id;

                // 模拟输入端口状态变化
                componentStates.set(inputId, 1);
                updatePortDisplay(inputId);

                // 模拟信号传播到LED
                const inputState = componentStates.get(inputId) || 0;
                const ledLogic = logicFunctions['led-diode'];
                const ledOutput = ledLogic([inputState]);

                componentStates.set(ledId, ledOutput);
                updateLEDDisplay(led, ledOutput);

                setTimeout(() => {
                    componentStates.set(inputId, 0);
                    updatePortDisplay(inputId);

                    const inputState = componentStates.get(inputId) || 0;
                    const ledOutput = ledLogic([inputState]);

                    componentStates.set(ledId, ledOutput);
                    updateLEDDisplay(led, ledOutput);
                }, 2000);

                return true;
            };

            // 全局拖动和调整大小功能
            window.makeDraggableAndResizable = function(element) {
                const header = element.querySelector('.dialog-header');
                const resizeHandle = element.querySelector('.resize-handle');

                if (!header) return;

                let isDragging = false;
                let isResizing = false;
                let startX = 0;
                let startY = 0;
                let elementX = 0;
                let elementY = 0;
                let elementWidth = 0;
                let elementHeight = 0;

                // 拖动功能
                header.addEventListener('mousedown', dragStart);

                function dragStart(e) {
                    // 检查是否点击的是关闭按钮
                    if (e.target.classList.contains('dialog-close')) {
                        return;
                    }

                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;

                    // 获取当前元素的位置
                    const rect = element.getBoundingClientRect();
                    elementX = rect.left;
                    elementY = rect.top;

                    header.style.cursor = 'grabbing';

                    // 添加全局事件监听器
                    document.addEventListener('mousemove', drag);
                    document.addEventListener('mouseup', dragEnd);

                    e.preventDefault();
                }

                function drag(e) {
                    if (!isDragging) return;

                    e.preventDefault();

                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;

                    const newX = elementX + deltaX;
                    const newY = elementY + deltaY;

                    // 限制在视窗内
                    const maxX = window.innerWidth - element.offsetWidth;
                    const maxY = window.innerHeight - element.offsetHeight;

                    const constrainedX = Math.max(0, Math.min(newX, maxX));
                    const constrainedY = Math.max(0, Math.min(newY, maxY));

                    element.style.left = constrainedX + 'px';
                    element.style.top = constrainedY + 'px';
                    element.style.transform = 'none'; // 清除居中的transform
                }

                function dragEnd(e) {
                    isDragging = false;
                    header.style.cursor = 'move';

                    // 移除全局事件监听器
                    document.removeEventListener('mousemove', drag);
                    document.removeEventListener('mouseup', dragEnd);
                }

                // 调整大小功能
                if (resizeHandle) {
                    resizeHandle.addEventListener('mousedown', resizeStart);

                    function resizeStart(e) {
                        isResizing = true;
                        startX = e.clientX;
                        startY = e.clientY;

                        // 获取当前元素的尺寸
                        const rect = element.getBoundingClientRect();
                        elementWidth = rect.width;
                        elementHeight = rect.height;

                        // 添加全局事件监听器
                        document.addEventListener('mousemove', resize);
                        document.addEventListener('mouseup', resizeEnd);

                        e.preventDefault();
                        e.stopPropagation();
                    }

                    function resize(e) {
                        if (!isResizing) return;

                        e.preventDefault();

                        const deltaX = e.clientX - startX;
                        const deltaY = e.clientY - startY;

                        const newWidth = elementWidth + deltaX;
                        const newHeight = elementHeight + deltaY;

                        // 设置最小尺寸
                        const minWidth = parseInt(element.style.minWidth) || 400;
                        const minHeight = parseInt(element.style.minHeight) || 300;

                        // 限制最大尺寸（不超过视窗）
                        const maxWidth = window.innerWidth - parseInt(element.style.left || 0);
                        const maxHeight = window.innerHeight - parseInt(element.style.top || 0);

                        const constrainedWidth = Math.max(minWidth, Math.min(newWidth, maxWidth));
                        const constrainedHeight = Math.max(minHeight, Math.min(newHeight, maxHeight));

                        element.style.width = constrainedWidth + 'px';
                        element.style.height = constrainedHeight + 'px';
                    }

                    function resizeEnd(e) {
                        isResizing = false;

                        // 移除全局事件监听器
                        document.removeEventListener('mousemove', resize);
                        document.removeEventListener('mouseup', resizeEnd);
                    }
                }
            };

        });
    </script>

</body>

</html>