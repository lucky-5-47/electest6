# 连线功能实现详解

## 1. 锚点（Anchor）定义与初始化
- **锚点类型**：
  - 输入锚点（`input-anchor`）：用于接收信号。
  - 输出锚点（`output-anchor`）：用于发送信号。
- **实现方式**：
  - 在SVG中通过`<circle>`元素定义锚点，通过`data-anchor-type`属性标记类型。
  - 锚点坐标基于元件的`transform`属性转换为画布坐标。
  

## 2. 连线创建流程
1. **开始连线**：
   - 点击锚点时，触发鼠标按下事件，保存起点坐标（`startX`, `startY`）。
   - 创建临时`<path>`元素作为连线预览。
2. **动态连线**：
   - 鼠标移动时，实时更新临时连线的终点坐标（`endX`, `endY`）。
   - 实时调用 calculateBentPath，根据临时连线的终点坐标，更新临时连线的路径（`d`属性）。
   - 动态检测终点是否靠近其他锚点或连线（分支锚点）。
3. **结束连线**：
   - 检测终点是否靠近其他锚点或连线：
     - 若靠近锚点，创建永久连线并存储到`wires`数组。
     - 若靠近连线，创建分支锚点并生成分支连线。
     - 否则取消连线。
   - 鼠标松开时，会调用 createBentWire，传入起始点（dragStartPoint）和终点坐标，采用路径计算方法calculateBentPath，生成永久连线。

## 3. 连线路径计算
- **路径生成**：
  - 使用`calculateBentPath`函数生成带转弯的路径。
  - 根据起点和终点的相对位置（水平或垂直距离更大）决定转弯方向。
  - 支持分支连线的路径计算（继承父连线的起点/分支点坐标）。
- **转弯逻辑**：
  - 水平优先：先水平后垂直转弯。
  - 垂直优先：先垂直后水平转弯。
  - 转弯处添加圆角（`cornerRadius`）。
- **动态调整**：
  - 根据画布缩放比例动态调整路径的圆角半径和转弯点位置。

## 4. 连线的递归更新
- **递归更新**：
  - 遍历`updatedWires`确保连线没有更新过。
  - 调用 `updateWirePosition(wire)` 更新当前连线的位置。
  - 查找所有以当前连线为分支源的连线（`branchWires`）。
  - 对每一条分支连线递归调用 `updateWireRecursively`，确保所有分支连线也被更新。
- **updateWirePosition(wire)**：
  - 对分支连线
    - 调用`updateBranchPoint`函数更新分支点位置。
    - 使用 `getBoundingClientRect` 获取终点相对于画布的位置，并更新路径。
  - 锚点连接到线
    - 根据 `wire.connectionRatio` 计算目标连线上的连接点位置。
    - 更新路径并存储连接点坐标。
  - 普通连线
    - 直接通过 `wire.start` 和 `wire.end` 获取起点和终点的位置。
    - 更新路径并存储连接点坐标。



## 5. 多连线与分支功能
### 5.1 多连线锚点支持
- **核心数据结构**：
  - 锚点的连接：创建Map对象，使用`anchorConnections`映射表：记录锚点间的连接关系。
    - 键(key): 为锚点`DOM`元素
    - 值(value): 为该锚点连接的所有目标锚点数组
  - 连线数组wires：存储所有锚点和连线的关系
- **核心机制**：
  - 每条连线都是一个独立的`SVG path`元素，具有唯一的DOM标识
  - 每条连线作为独立对象存储在`wires`数组中
  - 通过`anchorConnections Map`实现一对多关系，一个锚点可以连接到多个目标
  - 信号传播时会遍历锚点的所有连接
### 5.2 连线分支功能
- 如果判断起始点在连线上，计算鼠标点击的位置
- 使用dragStartPoint记录分支连线的起点坐标
- 鼠标释放时，创建分支连线
- 计算branchRatio: 分支点在原连线上的位置比例

## 6. 关键代码片段
### 6.1 创建连线
```javascript
function createBentWire(startX, startY, endX, endY) {
  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  path.setAttribute('d', calculateBentPath(startX, startY, endX, endY));
  path.setAttribute('stroke', 'black');
  path.setAttribute('stroke-width', '2');
  return path;
}
```

### 6.2 连线拐弯
```javascript
function calculateBentPath(startX, startY, endX, endY) {
                const dx = endX - startX;
                const dy = endY - startY;

                // 如果距离很近，使用直线
                if (Math.abs(dx) < 50 && Math.abs(dy) < 50) {
                    return `M ${startX} ${startY} L ${endX} ${endY}`;
                }
                ......
}
```

### 6.3 三个响应事件 
```javascript
canvas.addEventListener('mousedown', function (e) {});
canvas.addEventListener('mousemove', function (e) {});
canvas.addEventListener('mouseup', function (e) {});
```